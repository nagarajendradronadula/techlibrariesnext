[
    {
      "id": "boost",
      "name": "Boost",
      "category": "CLI/Utils",
      "description": "Boost is a collection of peer-reviewed, portable C++ libraries that extend the functionality of the C++ Standard Library. It provides utilities for smart pointers, threading, regular expressions, file system operations, and more.",
      "story": "Boost was initiated in 1998 by a group of C++ experts to provide high-quality, reusable C++ libraries. Many Boost libraries have been proposed and incorporated into the C++ Standard Library (C++11 and onwards). Boost emphasizes performance, portability, and robustness.",
      "installation": {
        "linux": "sudo apt install libboost-all-dev",
        "mac": "brew install boost",
        "windows": "Use precompiled binaries from https://www.boost.org/users/download/"
      },
      "usage": {
        "overview": "Boost provides a wide range of libraries covering various domains: smart pointers, containers, algorithms, threading, asynchronous I/O, serialization, date/time, filesystem, and more. Each library has its own API, and many can be used header-only.",
        "basic_examples": [
          {
            "title": "Using smart pointers",
            "code": "#include <boost/shared_ptr.hpp>\n#include <iostream>\n\nint main() {\n    boost::shared_ptr<int> ptr(new int(10));\n    std::cout << *ptr << std::endl;\n    return 0;\n}",
            "explanation": "Demonstrates the usage of Boost shared_ptr to manage memory automatically."
          },
          {
            "title": "Using Boost filesystem",
            "code": "#include <boost/filesystem.hpp>\n#include <iostream>\n\nint main() {\n    boost::filesystem::path p(\"test.txt\");\n    if (boost::filesystem::exists(p)) {\n        std::cout << p << \" exists.\" << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Checks if a file exists using Boost Filesystem."
          }
        ],
        "advanced_examples": [
          {
            "title": "Multithreading with Boost.Thread",
            "code": "#include <boost/thread.hpp>\n#include <iostream>\n\nvoid threadFunction() {\n    std::cout << \"Hello from thread!\" << std::endl;\n}\n\nint main() {\n    boost::thread t(threadFunction);\n    t.join();\n    return 0;\n}",
            "explanation": "Creates and runs a thread using Boost.Thread."
          },
          {
            "title": "Regular expressions",
            "code": "#include <boost/regex.hpp>\n#include <iostream>\n#include <string>\n\nint main() {\n    boost::regex expr(\"\\\\d+\");\n    std::string s = \"There are 123 apples\";\n    boost::smatch match;\n    if(boost::regex_search(s, match, expr)) {\n        std::cout << match[0] << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Uses Boost.Regex to find digits in a string."
          },
          {
            "title": "Asynchronous I/O with Boost.Asio",
            "code": "// Using Boost.Asio for networking or asynchronous operations via io_context and sockets."
          }
        ],
        "best_practices": [
          "Use header-only libraries when possible for simplicity.",
          "Prefer Boost smart pointers over raw pointers for memory safety.",
          "Combine Boost.Asio with modern C++ async/await or futures for network programming.",
          "Check compatibility with C++ Standard version for each Boost library.",
          "Keep Boost libraries updated as they frequently improve performance and fix bugs."
        ],
        "error_handling": [
          {
            "error": "boost::filesystem::filesystem_error",
            "solution": "Occurs when filesystem operations fail. Check paths, permissions, and existence."
          },
          {
            "error": "boost::bad_weak_ptr",
            "solution": "Thrown when a shared_ptr or weak_ptr is misused. Ensure proper ownership semantics."
          }
        ]
      },
      "references": {
        "official_docs": "https://www.boost.org/doc/",
        "github": "https://github.com/boostorg/boost"
      }
    },
    {
      "id": "qt",
      "name": "Qt",
      "category": "CLI/Utils",
      "description": "Qt is a comprehensive C++ framework for developing cross-platform applications and graphical user interfaces (GUIs). It provides tools for GUI design, event handling, networking, threading, and more.",
      "story": "Qt was first developed by Haavard Nord and Eirik Chambe-Eng in 1991. It became widely popular for building desktop, mobile, and embedded applications due to its cross-platform capabilities and rich set of libraries. Qt supports modern C++ and integrates with QML for declarative UI design.",
      "installation": {
        "linux": "sudo apt install qt5-default qtcreator",
        "mac": "brew install qt",
        "windows": "Download Qt installer from https://www.qt.io/download"
      },
      "usage": {
        "overview": "Qt provides modules for GUI, networking, multimedia, database access, and more. It follows an object-oriented and signal-slot architecture to handle events and interactions efficiently.",
        "basic_examples": [
          {
            "title": "Simple GUI application",
            "code": "#include <QApplication>\n#include <QLabel>\n\nint main(int argc, char *argv[]) {\n    QApplication app(argc, argv);\n    QLabel label(\"Hello, Qt!\");\n    label.show();\n    return app.exec();\n}",
            "explanation": "Creates a basic Qt application with a window displaying 'Hello, Qt!'."
          },
          {
            "title": "Button click with signal-slot",
            "code": "#include <QApplication>\n#include <QPushButton>\n#include <QObject>\n#include <iostream>\n\nint main(int argc, char *argv[]) {\n    QApplication app(argc, argv);\n    QPushButton button(\"Click Me\");\n    QObject::connect(&button, &QPushButton::clicked, [](){ std::cout << \"Button clicked!\" << std::endl; });\n    button.show();\n    return app.exec();\n}",
            "explanation": "Demonstrates Qt's signal-slot mechanism by printing a message when a button is clicked."
          }
        ],
        "advanced_examples": [
          {
            "title": "Using Qt for networking",
            "code": "// Use QTcpSocket, QUdpSocket, or QNetworkAccessManager for network operations."
          },
          {
            "title": "Multithreading in Qt",
            "code": "// Use QThread or QtConcurrent for running tasks in parallel."
          },
          {
            "title": "Database access",
            "code": "// Use QSqlDatabase and QSqlQuery to connect and interact with SQL databases."
          }
        ],
        "best_practices": [
          "Use signal-slot mechanism for event-driven programming instead of polling.",
          "Keep UI code and business logic separate.",
          "Use layouts instead of fixed coordinates for flexible GUI design.",
          "Prefer modern C++ features when writing Qt applications.",
          "Utilize Qt's resource system for managing assets like images and icons."
        ],
        "error_handling": [
          {
            "error": "QSqlError",
            "solution": "Check database connection, credentials, and SQL query syntax."
          },
          {
            "error": "QNetworkReply error",
            "solution": "Handle network errors by checking error codes and implementing retries."
          }
        ]
      },
      "references": {
        "official_docs": "https://doc.qt.io/",
        "github": "https://github.com/qt/qtbase"
      }
    },
    {
      "id": "poco",
      "name": "POCO C++ Libraries",
      "category": "Web",
      "description": "POCO (Portable Components) is a set of modern C++ libraries that provide building blocks for network-centric, portable applications. It includes modules for networking, HTTP, XML, JSON, threading, file system access, and more.",
      "story": "POCO was created by Günter Obiltschnig in 2005 to simplify C++ development for networked and portable applications. It focuses on providing robust, reusable, and modern C++ components while remaining lightweight and easy to integrate.",
      "installation": {
        "linux": "sudo apt install libpoco-dev",
        "mac": "brew install poco",
        "windows": "Download precompiled binaries or build from source: https://pocoproject.org/download.html"
      },
      "usage": {
        "overview": "POCO offers modules such as Foundation (core utilities), Net (networking), NetSSL (SSL/TLS), Util (configuration and logging), JSON, and XML. It supports asynchronous programming, HTTP clients/servers, file system utilities, and more.",
        "basic_examples": [
          {
            "title": "Using POCO HTTP Client",
            "code": "#include <Poco/Net/HTTPClientSession.h>\n#include <Poco/Net/HTTPRequest.h>\n#include <Poco/Net/HTTPResponse.h>\n#include <Poco/StreamCopier.h>\n#include <iostream>\n#include <sstream>\n\nint main() {\n    Poco::Net::HTTPClientSession session(\"www.example.com\");\n    Poco::Net::HTTPRequest req(Poco::Net::HTTPRequest::HTTP_GET, \"/\");\n    session.sendRequest(req);\n    Poco::Net::HTTPResponse res;\n    std::istream &is = session.receiveResponse(res);\n    std::stringstream ss;\n    Poco::StreamCopier::copyStream(is, ss);\n    std::cout << ss.str() << std::endl;\n    return 0;\n}",
            "explanation": "Performs a simple HTTP GET request using POCO's Net module and prints the response."
          },
          {
            "title": "Using POCO Filesystem utilities",
            "code": "#include <Poco/File.h>\n#include <iostream>\n\nint main() {\n    Poco::File file(\"test.txt\");\n    if (!file.exists()) {\n        file.createFile();\n        std::cout << \"File created.\" << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Checks for the existence of a file and creates it if missing using POCO Foundation utilities."
          }
        ],
        "advanced_examples": [
          {
            "title": "Multithreading with POCO",
            "code": "// Use Poco::Thread and Poco::Runnable to implement threaded tasks."
          },
          {
            "title": "JSON parsing and serialization",
            "code": "// Use Poco::JSON::Parser and Poco::JSON::Object to read/write JSON data."
          },
          {
            "title": "Building an HTTP server",
            "code": "// Use Poco::Net::HTTPServer, HTTPRequestHandler, and HTTPRequestHandlerFactory to create a server."
          }
        ],
        "best_practices": [
          "Use Foundation module for core utilities like threading, timers, and file system operations.",
          "Leverage Net and NetSSL for network programming and secure connections.",
          "Use JSON and XML modules for structured data handling.",
          "Separate logic into reusable components for maintainability.",
          "Properly handle exceptions from POCO modules to avoid runtime crashes."
        ],
        "error_handling": [
          {
            "error": "Poco::IOException",
            "solution": "Occurs during file or network I/O. Check paths, network availability, and permissions."
          },
          {
            "error": "Poco::Net::HTTPException",
            "solution": "Thrown for HTTP request/response issues. Verify URLs, request formatting, and server availability."
          }
        ]
      },
      "references": {
        "official_docs": "https://pocoproject.org/documentation/",
        "github": "https://github.com/pocoproject/poco"
      }
    },
    {
      "id": "nlohmann-json",
      "name": "nlohmann-json",
      "category": "Web",
      "description": "nlohmann-json is a modern C++ library for parsing, serializing, and manipulating JSON data. It provides an easy-to-use, STL-like interface and is header-only, making integration straightforward.",
      "story": "nlohmann-json was created by Niels Lohmann in 2013 to offer a simple, intuitive, and type-safe way to handle JSON in C++. It quickly became popular due to its ease of use, compatibility with modern C++ standards, and rich feature set.",
      "installation": {
        "linux": "sudo apt install nlohmann-json3-dev",
        "mac": "brew install nlohmann-json",
        "windows": "Download single header from https://github.com/nlohmann/json/releases or use vcpkg: vcpkg install nlohmann-json"
      },
      "usage": {
        "overview": "nlohmann-json allows creating JSON objects, parsing JSON strings, and serializing JSON data. It provides STL-like access, iterators, and convenient methods for manipulating nested data structures.",
        "basic_examples": [
          {
            "title": "Creating and accessing JSON",
            "code": "#include <nlohmann/json.hpp>\n#include <iostream>\n\nusing json = nlohmann::json;\n\nint main() {\n    json j;\n    j[\"name\"] = \"Alice\";\n    j[\"age\"] = 30;\n    std::cout << j[\"name\"] << \" is \" << j[\"age\"] << \" years old.\" << std::endl;\n    return 0;\n}",
            "explanation": "Creates a JSON object and accesses its fields using string keys."
          },
          {
            "title": "Parsing JSON string",
            "code": "#include <nlohmann/json.hpp>\n#include <iostream>\n#include <string>\n\nusing json = nlohmann::json;\n\nint main() {\n    std::string s = R\"({\"city\":\"NYC\",\"population\":8419000})\";\n    json j = json::parse(s);\n    std::cout << j[\"city\"] << std::endl;\n    return 0;\n}",
            "explanation": "Parses a JSON-formatted string into a JSON object and accesses its values."
          }
        ],
        "advanced_examples": [
          {
            "title": "Iterating over JSON objects",
            "code": "#include <nlohmann/json.hpp>\n#include <iostream>\n\nusing json = nlohmann::json;\n\nint main() {\n    json j = { {\"name\", \"Alice\"}, {\"age\", 30} };\n    for (auto& [key, value] : j.items()) {\n        std::cout << key << \": \" << value << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Demonstrates iterating over JSON key-value pairs using structured bindings."
          },
          {
            "title": "Serializing JSON to string",
            "code": "#include <nlohmann/json.hpp>\n#include <iostream>\n\nusing json = nlohmann::json;\n\nint main() {\n    json j = { {\"name\", \"Bob\"}, {\"active\", true} };\n    std::string s = j.dump(4); // pretty print with 4 spaces\n    std::cout << s << std::endl;\n    return 0;\n}",
            "explanation": "Serializes a JSON object into a formatted string for readability."
          },
          {
            "title": "Working with arrays",
            "code": "#include <nlohmann/json.hpp>\n#include <iostream>\n\nusing json = nlohmann::json;\n\nint main() {\n    json j = {\"apple\", \"banana\", \"cherry\"};\n    j.push_back(\"date\");\n    for (auto& fruit : j) std::cout << fruit << std::endl;\n    return 0;\n}",
            "explanation": "Demonstrates creating a JSON array, adding elements, and iterating through it."
          }
        ],
        "best_practices": [
          "Prefer `json::parse` with try-catch blocks to handle malformed input.",
          "Use `dump()` with indentation for human-readable JSON output.",
          "Leverage STL-like iterators for manipulation of objects and arrays.",
          "Validate JSON structure before accessing deeply nested fields.",
          "Keep library updated to benefit from new C++ standard support and bug fixes."
        ],
        "error_handling": [
          {
            "error": "nlohmann::json::parse_error",
            "solution": "Occurs when parsing invalid JSON. Validate JSON format or wrap in try-catch."
          },
          {
            "error": "nlohmann::json::type_error",
            "solution": "Occurs when accessing a value with an incompatible type. Check JSON data types before access."
          }
        ]
      },
      "references": {
        "official_docs": "https://nlohmann.github.io/json/",
        "github": "https://github.com/nlohmann/json"
      }
    },
    {
      "id": "fmt",
      "name": "fmt",
      "category": "CLI/Utils",
      "description": "fmt is a modern C++ library for safe and fast string formatting. It provides a type-safe alternative to printf and std::stringstream, supporting Python-like format strings and compile-time checks.",
      "story": "fmt was created by Victor Zverovich to provide an efficient and safe formatting library for C++ that combines the convenience of Python’s str.format with C++ type safety. It became widely used and is the basis for C++20's std::format.",
      "installation": {
        "linux": "sudo apt install libfmt-dev",
        "mac": "brew install fmt",
        "windows": "Download and build from https://github.com/fmtlib/fmt"
      },
      "usage": {
        "overview": "fmt allows formatting strings using Python-like replacement fields with `{}`. It supports compile-time checking, positional arguments, named arguments, width, alignment, precision, and localization.",
        "basic_examples": [
          {
            "title": "Basic string formatting",
            "code": "#include <fmt/core.h>\n#include <iostream>\n\nint main() {\n    std::string name = \"Alice\";\n    int age = 30;\n    std::cout << fmt::format(\"{} is {} years old\", name, age) << std::endl;\n    return 0;\n}",
            "explanation": "Formats a string using `{}` placeholders for variables."
          },
          {
            "title": "Named arguments",
            "code": "#include <fmt/core.h>\n#include <iostream>\n\nint main() {\n    std::cout << fmt::format(\"{name} is {age} years old\", fmt::arg(\"name\", \"Bob\"), fmt::arg(\"age\", 25)) << std::endl;\n    return 0;\n}",
            "explanation": "Demonstrates using named arguments for string formatting."
          }
        ],
        "advanced_examples": [
          {
            "title": "Formatting numbers",
            "code": "#include <fmt/core.h>\n#include <iostream>\n\nint main() {\n    double pi = 3.14159265;\n    std::cout << fmt::format(\"Pi rounded to 2 decimals: {:.2f}\", pi) << std::endl;\n    return 0;\n}",
            "explanation": "Formats a floating-point number with 2 decimal places."
          },
          {
            "title": "Alignment and width",
            "code": "#include <fmt/core.h>\n#include <iostream>\n\nint main() {\n    std::cout << fmt::format(\"|{:<10}|{:^10}|{:>10}|\", \"left\", \"center\", \"right\") << std::endl;\n    return 0;\n}",
            "explanation": "Shows left, center, and right alignment within a fixed width."
          },
          {
            "title": "Printing to file",
            "code": "#include <fmt/core.h>\n#include <fstream>\n\nint main() {\n    std::ofstream file(\"output.txt\");\n    fmt::print(file, \"Hello {}!\\n\", \"World\");\n    return 0;\n}",
            "explanation": "Writes a formatted string directly to a file."
          },
          {
            "title": "Compile-time formatting",
            "code": "#include <fmt/compile.h>\n#include <iostream>\n\nint main() {\n    std::cout << fmt::format(FMT_COMPILE(\"Hello {}!\"), \"World\") << std::endl;\n    return 0;\n}",
            "explanation": "Demonstrates compile-time checked formatting for better performance and safety."
          }
        ],
        "best_practices": [
          "Prefer fmt::format over printf for type safety.",
          "Use named arguments for clarity in long format strings.",
          "Leverage compile-time formatting for performance-critical code.",
          "Use fmt::print for simple output to console or files.",
          "Combine fmt with logging libraries to format log messages safely."
        ],
        "error_handling": [
          {
            "error": "fmt::format_error",
            "solution": "Thrown if the format string is invalid or arguments do not match placeholders. Ensure proper format specifiers and argument types."
          },
          {
            "error": "std::out_of_range",
            "solution": "Occurs if an argument index in the format string is out of range. Verify that placeholders match the number of provided arguments."
          }
        ]
      },
      "references": {
        "official_docs": "https://fmt.dev/latest/index.html",
        "github": "https://github.com/fmtlib/fmt"
      }
    },
    {
      "id": "spdlog",
      "name": "spdlog",
      "category": "CLi/Utils",
      "description": "spdlog is a fast, header-only C++ logging library. It provides synchronous and asynchronous logging capabilities with support for multiple sinks, custom formatting, and high-performance logging suitable for real-time applications.",
      "story": "spdlog was created by Gabi Melman to offer a modern and high-performance logging library for C++ developers. It emphasizes simplicity, speed, and flexibility, becoming popular in projects where efficient logging is critical, including gaming, finance, and network applications.",
      "installation": {
        "linux": "sudo apt install libspdlog-dev",
        "mac": "brew install spdlog",
        "windows": "Download from https://github.com/gabime/spdlog or use vcpkg: vcpkg install spdlog"
      },
      "usage": {
        "overview": "spdlog allows logging messages with different severity levels (trace, debug, info, warn, error, critical) to console, files, or custom sinks. It supports formatting using the fmt library and provides both thread-safe and asynchronous logging.",
        "basic_examples": [
          {
            "title": "Basic console logging",
            "code": "#include <spdlog/spdlog.h>\n\nint main() {\n    spdlog::info(\"Hello, {}!\", \"world\");\n    spdlog::warn(\"This is a warning\");\n    spdlog::error(\"This is an error\");\n    return 0;\n}",
            "explanation": "Logs messages to the console with different severity levels using fmt-style formatting."
          },
          {
            "title": "Logging to a file",
            "code": "#include <spdlog/spdlog.h>\n#include <spdlog/sinks/basic_file_sink.h>\n\nint main() {\n    auto file_logger = spdlog::basic_logger_mt(\"file_logger\", \"logs.txt\");\n    file_logger->info(\"File logger initialized\");\n    return 0;\n}",
            "explanation": "Creates a file logger that writes log messages to `logs.txt`."
          }
        ],
        "advanced_examples": [
          {
            "title": "Asynchronous logging",
            "code": "#include <spdlog/spdlog.h>\n#include <spdlog/async.h>\n#include <spdlog/sinks/basic_file_sink.h>\n\nint main() {\n    spdlog::init_thread_pool(8192, 1);\n    auto async_file = spdlog::basic_logger_mt<spdlog::async_factory>(\"async_file\", \"async_logs.txt\");\n    async_file->info(\"Async logging example\");\n    return 0;\n}",
            "explanation": "Sets up asynchronous logging to improve performance for high-frequency log messages."
          },
          {
            "title": "Custom formatting",
            "code": "#include <spdlog/spdlog.h>\n#include <spdlog/sinks/stdout_color_sinks.h>\n\nint main() {\n    auto console = spdlog::stdout_color_mt(\"console\");\n    console->set_pattern(\"[%Y-%m-%d %H:%M:%S] [%^%l%$] %v\");\n    console->info(\"Custom formatted log message\");\n    return 0;\n}",
            "explanation": "Demonstrates setting a custom log pattern with timestamps, log levels, and message content."
          },
          {
            "title": "Rotating file logger",
            "code": "#include <spdlog/spdlog.h>\n#include <spdlog/sinks/rotating_file_sink.h>\n\nint main() {\n    auto rotating_logger = spdlog::rotating_logger_mt(\"rotating\", \"rotating_logs.txt\", 1024*1024*5, 3);\n    rotating_logger->info(\"This is a rotating log example\");\n    return 0;\n}",
            "explanation": "Creates a rotating file logger that maintains multiple log files of a specified maximum size."
          },
          {
            "title": "Logging with multiple sinks",
            "code": "#include <spdlog/spdlog.h>\n#include <spdlog/sinks/stdout_color_sinks.h>\n#include <spdlog/sinks/basic_file_sink.h>\n\nint main() {\n    std::vector<spdlog::sink_ptr> sinks;\n    sinks.push_back(std::make_shared<spdlog::sinks::stdout_color_sink_mt>());\n    sinks.push_back(std::make_shared<spdlog::sinks::basic_file_sink_mt>(\"multi_sink.txt\"));\n    auto logger = std::make_shared<spdlog::logger>(\"multi_logger\", begin(sinks), end(sinks));\n    spdlog::register_logger(logger);\n    logger->info(\"Logging to multiple sinks\");\n    return 0;\n}",
            "explanation": "Logs messages simultaneously to console and a file using multiple sinks."
          }
        ],
        "best_practices": [
          "Use asynchronous logging for high-performance applications to avoid blocking threads.",
          "Set log levels appropriately for development, testing, and production.",
          "Rotate log files to manage disk space for long-running applications.",
          "Use consistent log patterns for readability and structured log analysis.",
          "Leverage multiple sinks for different logging targets (console, files, network)."
        ],
        "error_handling": [
          {
            "error": "spdlog::spdlog_ex",
            "solution": "Thrown when logger creation fails, e.g., due to file access issues. Ensure file paths are valid and accessible."
          }
        ]
      },
      "references": {
        "official_docs": "https://spdlog.docsforge.com/",
        "github": "https://github.com/gabime/spdlog"
      }
    },
    {
      "id": "catch2",
      "name": "Catch2",
      "category": "Testing",
      "description": "Catch2 is a modern, header-only C++ unit testing framework. It provides a simple syntax for writing test cases and assertions, making it easy to write, maintain, and execute tests for C++ projects.",
      "story": "Catch2 was created by Phil Nash as the successor to the original Catch framework. Its goal is to simplify unit testing in C++ by providing expressive macros, automatic test registration, and rich reporting while being lightweight and easy to integrate.",
      "installation": {
        "linux": "sudo apt install catch2",
        "mac": "brew install catch2",
        "windows": "Download the single header from https://github.com/catchorg/Catch2/releases"
      },
      "usage": {
        "overview": "Catch2 allows defining test cases with `TEST_CASE` macros and verifying conditions using `REQUIRE`, `CHECK`, and related assertions. It supports sections, tags, BDD-style tests, and integration with build systems for automated testing.",
        "basic_examples": [
          {
            "title": "Simple test case",
            "code": "#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n\nTEST_CASE(\"Factorials are computed correctly\", \"[factorial]\") {\n    REQUIRE( Factorial(0) == 1 );\n    REQUIRE( Factorial(1) == 1 );\n    REQUIRE( Factorial(2) == 2 );\n    REQUIRE( Factorial(3) == 6 );\n}",
            "explanation": "Defines a test case to verify factorial computations using `REQUIRE` assertions."
          },
          {
            "title": "Using CHECK for non-fatal assertions",
            "code": "TEST_CASE(\"Vectors can be sized and resized\", \"[vector]\") {\n    std::vector<int> v(5);\n    CHECK( v.size() == 5 );\n    v.push_back(1);\n    CHECK( v.size() == 6 );\n}",
            "explanation": "`CHECK` allows multiple assertions in a test case without aborting on failure."
          }
        ],
        "advanced_examples": [
          {
            "title": "Sections for structuring tests",
            "code": "TEST_CASE(\"Testing different scenarios\") {\n    SECTION(\"Empty vector\") {\n        std::vector<int> v;\n        REQUIRE(v.empty());\n    }\n    SECTION(\"Non-empty vector\") {\n        std::vector<int> v = {1,2,3};\n        REQUIRE(v.size() == 3);\n    }\n}",
            "explanation": "Sections allow grouping related test scenarios within a single test case."
          },
          {
            "title": "Tagged test cases",
            "code": "TEST_CASE(\"String manipulation\", \"[string][manipulation]\") {\n    REQUIRE( toUpper(\"abc\") == \"ABC\" );\n}",
            "explanation": "Tags help in filtering and running specific subsets of tests via command line."
          },
          {
            "title": "BDD-style testing",
            "code": "SCENARIO(\"Vectors can be resized\") {\n    GIVEN(\"A vector with 3 elements\") {\n        std::vector<int> v = {1,2,3};\n        WHEN(\"an element is added\") {\n            v.push_back(4);\n            THEN(\"the size increases\") {\n                REQUIRE(v.size() == 4);\n            }\n        }\n    }\n}",
            "explanation": "Demonstrates behavior-driven development style tests using `SCENARIO`, `GIVEN`, `WHEN`, and `THEN`."
          }
        ],
        "best_practices": [
          "Use `REQUIRE` for critical assertions and `CHECK` for non-fatal checks.",
          "Organize tests with tags for selective execution.",
          "Use sections to reduce code duplication for similar test scenarios.",
          "Keep test cases small and focused on a single functionality.",
          "Integrate Catch2 tests with CI pipelines for automated testing."
        ],
        "error_handling": [
          {
            "error": "Assertion failure",
            "solution": "Catch2 will report failed assertions with line numbers and messages. Review the test case logic and input data."
          },
          {
            "error": "Test case not executed",
            "solution": "Ensure that `TEST_CASE` macros are correctly defined and that the test file is compiled with Catch2."
          }
        ]
      },
      "references": {
        "official_docs": "https://github.com/catchorg/Catch2/blob/devel/docs/tutorial.md",
        "github": "https://github.com/catchorg/Catch2"
      }
    },
    {
      "id": "gtest",
      "name": "Google Test",
      "category": "Testing",
      "description": "Google Test (gtest) is a robust C++ unit testing framework developed by Google. It provides a rich set of assertions, test fixtures, parameterized tests, and utilities to help write reliable and maintainable tests.",
      "story": "Google Test was created by Google engineers to provide a standardized and efficient way to write C++ unit tests. It supports both small-scale and large-scale projects, integrating well with CI pipelines and offering detailed test reporting.",
      "installation": {
        "linux": "sudo apt install libgtest-dev && cd /usr/src/gtest && sudo cmake . && sudo make && sudo cp *.a /usr/lib",
        "mac": "brew install googletest",
        "windows": "Download from https://github.com/google/googletest and build using CMake"
      },
      "usage": {
        "overview": "Google Test allows writing unit tests using `TEST` and `TEST_F` macros. It provides assertions like `EXPECT_EQ`, `ASSERT_TRUE`, `EXPECT_THROW`, supports test fixtures for shared setup/teardown, and parameterized tests for testing multiple inputs.",
        "basic_examples": [
          {
            "title": "Simple test case",
            "code": "#include <gtest/gtest.h>\n\nint Add(int a, int b) {\n    return a + b;\n}\n\nTEST(MathTest, AddPositiveNumbers) {\n    EXPECT_EQ(Add(2, 3), 5);\n}\n\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}",
            "explanation": "Defines a simple test case that checks if `Add(2, 3)` returns 5 using `EXPECT_EQ`."
          },
          {
            "title": "Using ASSERT vs EXPECT",
            "code": "TEST(MathTest, DivideTest) {\n    int x = 10;\n    int y = 2;\n    ASSERT_NE(y, 0); // stops test if y is zero\n    EXPECT_EQ(x / y, 5); // continues even if this fails\n}",
            "explanation": "`ASSERT_` stops the test immediately if the assertion fails, while `EXPECT_` continues execution."
          }
        ],
        "advanced_examples": [
          {
            "title": "Test fixture example",
            "code": "class MyTest : public ::testing::Test {\nprotected:\n    void SetUp() override {\n        value = 10;\n    }\n    int value;\n};\n\nTEST_F(MyTest, CheckValue) {\n    EXPECT_EQ(value, 10);\n}",
            "explanation": "Uses a test fixture for shared setup. `TEST_F` accesses members defined in the fixture."
          },
          {
            "title": "Parameterized tests",
            "code": "class FactorialTest : public ::testing::TestWithParam<std::pair<int,int>> {};\n\nTEST_P(FactorialTest, HandlesFactorial) {\n    auto [input, expected] = GetParam();\n    EXPECT_EQ(Factorial(input), expected);\n}\n\nINSTANTIATE_TEST_SUITE_P(FactorialTests, FactorialTest, ::testing::Values(\n    std::make_pair(0,1), std::make_pair(1,1), std::make_pair(3,6)\n));",
            "explanation": "Runs the same test with multiple input/output pairs using parameterized tests."
          },
          {
            "title": "Testing exceptions",
            "code": "TEST(ExceptionTest, ThrowsWhenNegative) {\n    EXPECT_THROW(FunctionThatThrows(-1), std::invalid_argument);\n}",
            "explanation": "Checks that the function throws an exception of the expected type."
          }
        ],
        "best_practices": [
          "Use `EXPECT_` for non-critical checks and `ASSERT_` for critical preconditions.",
          "Organize tests into logical test suites using `TEST` and `TEST_F`.",
          "Keep tests small, focused, and independent from each other.",
          "Use parameterized tests to cover multiple scenarios efficiently.",
          "Integrate Google Test with CI/CD pipelines for automated testing."
        ],
        "error_handling": [
          {
            "error": "Test failure",
            "solution": "Review the assertion message. Use `ASSERT_` or `EXPECT_` appropriately and check the input data or function logic."
          },
          {
            "error": "Segmentation fault in test",
            "solution": "Ensure proper initialization of objects and valid memory usage inside tests."
          }
        ]
      },
      "references": {
        "official_docs": "https://google.github.io/googletest/",
        "github": "https://github.com/google/googletest"
      }
    },
    {
      "id": "protobuf-cpp",
      "name": "Protobuf",
      "category": "Data",
      "description": "Protocol Buffers (Protobuf) is a language-neutral, platform-neutral, and extensible mechanism for serializing structured data. In C++, it allows defining message schemas and efficiently serializing/deserializing structured data for inter-process communication, data storage, and network protocols.",
      "story": "Protobuf was developed by Google to offer a compact and fast alternative to XML and JSON for data serialization. Developers write `.proto` files to define message structures, then generate C++ classes to handle serialization, deserialization, and validation, making it widely used in gRPC, distributed systems, and file storage.",
      "installation": {
        "linux": "sudo apt install protobuf-compiler libprotobuf-dev",
        "mac": "brew install protobuf",
        "windows": "Download precompiled binaries from https://github.com/protocolbuffers/protobuf/releases"
      },
      "usage": {
        "overview": "In C++, Protobuf uses generated classes from `.proto` files. You can serialize messages to binary strings or streams, parse messages from them, and use features like nested messages, enums, repeated fields, and optional fields for efficient and structured data representation.",
        "basic_examples": [
          {
            "title": "Defining a message in .proto",
            "code": "// person.proto\nsyntax = \"proto3\";\nmessage Person {\n  string name = 1;\n  int32 id = 2;\n  string email = 3;\n}",
            "explanation": "Defines a simple `Person` message with fields `name`, `id`, and `email` using unique tag numbers."
          },
          {
            "title": "Generating C++ classes",
            "code": "# Terminal command\nprotoc --cpp_out=. person.proto",
            "explanation": "Generates `person.pb.h` and `person.pb.cc` C++ source files to work with the `Person` message."
          },
          {
            "title": "Creating and serializing a message",
            "code": "#include \"person.pb.h\"\n#include <fstream>\n\nint main() {\n    Person p;\n    p.set_name(\"Alice\");\n    p.set_id(123);\n    p.set_email(\"alice@example.com\");\n\n    std::ofstream out(\"person.bin\", std::ios::binary);\n    p.SerializeToOstream(&out);\n    return 0;\n}",
            "explanation": "Creates a `Person` object, sets its fields, and serializes it to a binary file."
          },
          {
            "title": "Deserializing a message",
            "code": "#include \"person.pb.h\"\n#include <fstream>\n#include <iostream>\n\nint main() {\n    Person p;\n    std::ifstream in(\"person.bin\", std::ios::binary);\n    if (p.ParseFromIstream(&in)) {\n        std::cout << p.name() << \", \" << p.id() << \", \" << p.email() << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Reads the binary file and reconstructs the `Person` object, printing its fields."
          }
        ],
        "advanced_examples": [
          {
            "title": "Nested messages",
            "code": "message Address {\n  string street = 1;\n  string city = 2;\n}\nmessage Person {\n  string name = 1;\n  Address address = 2;\n}",
            "explanation": "Demonstrates defining nested messages in a `.proto` file."
          },
          {
            "title": "Repeated fields",
            "code": "message Person {\n  string name = 1;\n  repeated string phone_numbers = 2;\n}",
            "explanation": "Allows storing multiple phone numbers for a single person using `repeated` fields."
          },
          {
            "title": "Enumerations",
            "code": "enum PhoneType {\n  MOBILE = 0;\n  HOME = 1;\n  WORK = 2;\n}\nmessage PhoneNumber {\n  string number = 1;\n  PhoneType type = 2;\n}",
            "explanation": "Defines an enumeration to represent a fixed set of values for a field."
          },
          {
            "title": "Integration with gRPC in C++",
            "code": "// In .proto file\nservice PersonService {\n  rpc GetPerson(PersonRequest) returns (PersonResponse);\n}\n// Use protoc with gRPC plugin to generate C++ server/client stubs",
            "explanation": "Shows how Protobuf is used to define services and messages for C++ gRPC communication."
          }
        ],
        "best_practices": [
          "Always assign unique tag numbers and never reuse deleted ones to maintain backward compatibility.",
          "Use `proto3` syntax for simplicity and default values.",
          "Keep messages concise for efficient serialization.",
          "Use nested messages and enums to organize complex structures.",
          "Validate data before serialization and after deserialization when needed."
        ],
        "error_handling": [
          {
            "error": "ParseError",
            "solution": "Occurs when deserializing invalid or corrupted data. Ensure serialized data matches the expected message type."
          },
          {
            "error": "Type mismatch",
            "solution": "Assign correct data types to each field as defined in the `.proto` file."
          }
        ]
      },
      "references": {
        "official_docs": "https://developers.google.com/protocol-buffers/docs/cpptutorial",
        "github": "https://github.com/protocolbuffers/protobuf"
      }
    },
    {
      "id": "opencv-cpp",
      "name": "OpenCV",
      "category": "ML/AI",
      "description": "OpenCV (Open Source Computer Vision Library) is a powerful C++ library for computer vision, image processing, and machine learning. It provides a wide range of algorithms for real-time image and video analysis.",
      "story": "OpenCV was originally developed by Intel in 1999 to advance computer vision research. It provides highly optimized algorithms for image processing, object detection, facial recognition, and more. OpenCV is widely used in industry and research for real-time applications and robotics.",
      "installation": {
        "linux": "sudo apt install libopencv-dev",
        "mac": "brew install opencv",
        "windows": "Download pre-built binaries from https://opencv.org/releases/ and configure with CMake"
      },
      "usage": {
        "overview": "OpenCV in C++ provides classes and functions to read, write, process images and videos, and perform advanced computer vision tasks. It supports matrices (cv::Mat), image filters, feature detection, machine learning, and GPU acceleration.",
        "basic_examples": [
          {
            "title": "Read and display an image",
            "code": "#include <opencv2/opencv.hpp>\nint main() {\n    cv::Mat img = cv::imread(\"image.jpg\");\n    if(img.empty()) return -1;\n    cv::imshow(\"Image\", img);\n    cv::waitKey(0);\n    return 0;\n}",
            "explanation": "Reads an image from file and displays it in a window until a key is pressed."
          },
          {
            "title": "Convert to grayscale",
            "code": "#include <opencv2/opencv.hpp>\nint main() {\n    cv::Mat img = cv::imread(\"image.jpg\");\n    cv::Mat gray;\n    cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);\n    cv::imshow(\"Gray\", gray);\n    cv::waitKey(0);\n    return 0;\n}",
            "explanation": "Converts a color image to grayscale using OpenCV’s color conversion function."
          }
        ],
        "advanced_examples": [
          {
            "title": "Canny edge detection",
            "code": "#include <opencv2/opencv.hpp>\nint main() {\n    cv::Mat img = cv::imread(\"image.jpg\", cv::IMREAD_GRAYSCALE);\n    cv::Mat edges;\n    cv::Canny(img, edges, 100, 200);\n    cv::imshow(\"Edges\", edges);\n    cv::waitKey(0);\n    return 0;\n}",
            "explanation": "Detects edges in a grayscale image using the Canny algorithm."
          },
          {
            "title": "Video capture from webcam",
            "code": "#include <opencv2/opencv.hpp>\nint main() {\n    cv::VideoCapture cap(0);\n    if(!cap.isOpened()) return -1;\n    cv::Mat frame;\n    while(true) {\n        cap >> frame;\n        if(frame.empty()) break;\n        cv::imshow(\"Webcam\", frame);\n        if(cv::waitKey(1) == 'q') break;\n    }\n    return 0;\n}",
            "explanation": "Captures video from the default webcam and displays it in real-time."
          },
          {
            "title": "Drawing shapes",
            "code": "#include <opencv2/opencv.hpp>\nint main() {\n    cv::Mat img = cv::Mat::zeros(512,512,CV_8UC3);\n    cv::line(img, cv::Point(0,0), cv::Point(511,511), cv::Scalar(255,0,0), 5);\n    cv::rectangle(img, cv::Point(100,100), cv::Point(300,300), cv::Scalar(0,255,0), 3);\n    cv::circle(img, cv::Point(256,256), 50, cv::Scalar(0,0,255), -1);\n    cv::imshow(\"Shapes\", img);\n    cv::waitKey(0);\n    return 0;\n}",
            "explanation": "Draws lines, rectangles, and circles on an empty image using OpenCV drawing functions."
          },
          {
            "title": "Face detection using Haar cascades",
            "code": "#include <opencv2/opencv.hpp>\nint main() {\n    cv::CascadeClassifier face_cascade;\n    face_cascade.load(\"haarcascade_frontalface_default.xml\");\n    cv::Mat img = cv::imread(\"group.jpg\");\n    cv::Mat gray;\n    cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);\n    std::vector<cv::Rect> faces;\n    face_cascade.detectMultiScale(gray, faces);\n    for(auto &f : faces) cv::rectangle(img, f, cv::Scalar(255,0,0), 2);\n    cv::imshow(\"Faces\", img);\n    cv::waitKey(0);\n    return 0;\n}",
            "explanation": "Detects faces in an image using pre-trained Haar cascade classifiers and draws rectangles around them."
          }
        ],
        "best_practices": [
          "Use cv::Mat for all image operations for performance and flexibility.",
          "Release resources properly and close windows to prevent memory leaks.",
          "Use proper color space conversions when needed (BGR, RGB, GRAY).",
          "Optimize pipelines for real-time applications using GPU or multi-threading.",
          "Keep pre-trained models and classifiers organized for reuse."
        ],
        "error_handling": [
          {
            "error": "cv::Exception: OpenCV(…): error",
            "solution": "Check image paths and ensure the file exists before reading."
          },
          {
            "error": "Segmentation fault",
            "solution": "Ensure Mat objects are initialized and not empty before performing operations."
          },
          {
            "error": "CascadeClassifier load failed",
            "solution": "Verify the path to Haar cascade XML files and that they are accessible."
          }
        ]
      },
      "references": {
        "official_docs": "https://docs.opencv.org/4.x/",
        "github": "https://github.com/opencv/opencv"
      }
    },
    {
      "id": "eigen",
      "name": "Eigen",
      "category": "Data",
      "description": "Eigen is a high-performance C++ template library for linear algebra, including matrices, vectors, numerical solvers, and related algorithms. It is widely used in scientific computing, machine learning, robotics, and computer graphics.",
      "story": "Eigen was created by Gael Guennebaud and Benoit Jacob to provide a fast, flexible, and easy-to-use library for linear algebra in C++. Its template-based design allows for efficient computations at compile-time and runtime. Eigen is highly optimized, supports arbitrary-sized matrices, and integrates seamlessly with other C++ libraries.",
      "installation": {
        "linux": "sudo apt install libeigen3-dev",
        "mac": "brew install eigen",
        "windows": "Download from https://gitlab.com/libeigen/eigen and include headers in your project"
      },
      "usage": {
        "overview": "Eigen allows defining fixed-size and dynamic-size matrices and vectors, performing arithmetic, solving linear systems, computing eigenvalues, performing decompositions (LU, QR, SVD), and supporting advanced operations like tensor computations.",
        "basic_examples": [
          {
            "title": "Defining matrices and vectors",
            "code": "#include <Eigen/Dense>\n#include <iostream>\nint main() {\n    Eigen::Matrix3d mat;\n    mat << 1, 2, 3,\n           4, 5, 6,\n           7, 8, 9;\n    Eigen::Vector3d vec(1, 2, 3);\n    std::cout << mat << std::endl;\n    std::cout << vec << std::endl;\n    return 0;\n}",
            "explanation": "Creates a 3x3 matrix and a 3-dimensional vector, initializing them with values and printing them."
          },
          {
            "title": "Matrix arithmetic",
            "code": "Eigen::Matrix2d A;\nA << 1, 2, 3, 4;\nEigen::Matrix2d B;\nB << 5, 6, 7, 8;\nEigen::Matrix2d C = A + B;\nstd::cout << C << std::endl;",
            "explanation": "Performs element-wise addition of two 2x2 matrices."
          }
        ],
        "advanced_examples": [
          {
            "title": "Solving linear systems",
            "code": "Eigen::Matrix2d A;\nA << 3, 1, 1, 2;\nEigen::Vector2d b(9, 8);\nEigen::Vector2d x = A.colPivHouseholderQr().solve(b);\nstd::cout << x << std::endl;",
            "explanation": "Solves a linear system Ax = b using QR decomposition."
          },
          {
            "title": "Eigenvalues and eigenvectors",
            "code": "Eigen::Matrix2d A;\nA << 1, 2, 2, 3;\nEigen::EigenSolver<Eigen::Matrix2d> solver(A);\nstd::cout << 'Eigenvalues: ' << solver.eigenvalues() << std::endl;\nstd::cout << 'Eigenvectors: ' << solver.eigenvectors() << std::endl;",
            "explanation": "Computes eigenvalues and eigenvectors of a 2x2 matrix."
          },
          {
            "title": "Matrix decompositions",
            "code": "Eigen::Matrix3d A;\nA << 1, 2, 3, 0, 1, 4, 5, 6, 0;\nEigen::FullPivLU<Eigen::Matrix3d> lu(A);\nstd::cout << 'Rank: ' << lu.rank() << std::endl;",
            "explanation": "Performs LU decomposition and computes the rank of a matrix."
          },
          {
            "title": "Dynamic-size matrices",
            "code": "Eigen::MatrixXd mat(4,4);\nmat.setRandom();\nstd::cout << mat << std::endl;",
            "explanation": "Defines a dynamic-size 4x4 matrix and fills it with random values."
          }
        ],
        "best_practices": [
          "Use fixed-size matrices for small, performance-critical computations.",
          "Use `.noalias()` when performing chained operations to avoid unnecessary temporaries.",
          "Leverage built-in decompositions (LU, QR, SVD) instead of implementing your own.",
          "Use Eigen’s expression templates for efficient vectorized operations.",
          "Include only necessary headers (Dense, Sparse, LU, etc.) to reduce compilation times."
        ],
        "error_handling": [
          {
            "error": "Assertion failed",
            "solution": "Occurs when matrix dimensions are incompatible. Check that operations are dimensionally correct."
          },
          {
            "error": "Eigen decomposition fails",
            "solution": "Ensure matrices are square when required and check that numerical stability conditions are met."
          }
        ]
      },
      "references": {
        "official_docs": "https://eigen.tuxfamily.org/dox/",
        "github": "https://gitlab.com/libeigen/eigen"
      }
    },
    {
      "id": "cereal",
      "name": "Cereal",
      "category": "Data",
      "description": "Cereal is a C++11 library for serialization of data structures. It allows converting C++ objects to JSON, XML, or binary formats, and deserializing them back into objects efficiently and safely.",
      "story": "Cereal was developed by USCiLab to provide a modern, easy-to-use, and type-safe serialization library for C++. It leverages C++11 features like templates and smart pointers, making serialization and deserialization intuitive and flexible for both small and complex data structures.",
      "installation": {
        "linux": "sudo apt install libcereal-dev",
        "mac": "brew install cereal",
        "windows": "Download from https://uscilab.github.io/cereal/ and include headers in your project"
      },
      "usage": {
        "overview": "Cereal allows serialization of standard C++ data types, STL containers, and custom classes. You can serialize objects to JSON, XML, or binary archives, and deserialize them with minimal boilerplate.",
        "basic_examples": [
          {
            "title": "Serializing to JSON",
            "code": "#include <cereal/archives/json.hpp>\n#include <fstream>\nstruct MyData {\n    int x; float y;\n    template<class Archive>\n    void serialize(Archive & ar) {\n        ar(x, y);\n    }\n};\nint main() {\n    MyData data{42, 3.14f};\n    std::ofstream os(\"data.json\");\n    cereal::JSONOutputArchive archive(os);\n    archive(data);\n}",
            "explanation": "Serializes a simple struct `MyData` to a JSON file using Cereal."
          },
          {
            "title": "Deserializing from JSON",
            "code": "#include <cereal/archives/json.hpp>\n#include <fstream>\nMyData data;\nstd::ifstream is(\"data.json\");\ncereal::JSONInputArchive archive(is);\narchive(data);\nstd::cout << data.x << \", \" << data.y << std::endl;",
            "explanation": "Reads the JSON file back into a `MyData` object."
          }
        ],
        "advanced_examples": [
          {
            "title": "Serializing STL containers",
            "code": "#include <cereal/archives/json.hpp>\n#include <vector>\n#include <fstream>\nint main() {\n    std::vector<int> numbers{1,2,3,4,5};\n    std::ofstream os(\"numbers.json\");\n    cereal::JSONOutputArchive archive(os);\n    archive(numbers);\n}",
            "explanation": "Cereal can directly serialize STL containers like vectors, maps, and sets."
          },
          {
            "title": "Serializing nested objects",
            "code": "struct Point { int x, y; template<class Archive> void serialize(Archive & ar){ ar(x,y); } };\nstruct Shape { Point p; int size; template<class Archive> void serialize(Archive & ar){ ar(p, size); } };",
            "explanation": "Cereal supports nested structures, recursively serializing inner objects."
          },
          {
            "title": "Binary serialization",
            "code": "#include <cereal/archives/binary.hpp>\nstd::ofstream os(\"data.bin\", std::ios::binary);\ncereal::BinaryOutputArchive archive(os);\narchive(data);",
            "explanation": "Cereal can serialize data in binary format for compact storage and faster I/O."
          },
          {
            "title": "XML serialization",
            "code": "#include <cereal/archives/xml.hpp>\nstd::ofstream os(\"data.xml\");\ncereal::XMLOutputArchive archive(os);\narchive(data);",
            "explanation": "Cereal can serialize objects to XML format, which is human-readable and widely used."
          }
        ],
        "best_practices": [
          "Use template `serialize` functions in your classes for custom serialization.",
          "Prefer binary archives for performance and JSON/XML for readability.",
          "Keep serialization code simple and minimal for maintainability.",
          "Avoid serializing pointers directly unless using smart pointers handled by Cereal.",
          "Ensure backward compatibility by adding default values when extending data structures."
        ],
        "error_handling": [
          {
            "error": "ArchiveException",
            "solution": "Occurs if the archive cannot read/write data correctly. Check file paths and ensure the archive matches the serialized format."
          },
          {
            "error": "Type mismatch",
            "solution": "Ensure the types during deserialization match exactly what was serialized."
          }
        ]
      },
      "references": {
        "official_docs": "https://uscilab.github.io/cereal/",
        "github": "https://github.com/USCiLab/cereal"
      }
    },
    {
      "id": "cxxopts",
      "name": "cxxopts",
      "category": "CLI/Utils",
      "description": "cxxopts is a lightweight C++ library for parsing command-line options. It provides a simple and modern API to define options, parse arguments, and handle help messages, making it ideal for CLI applications.",
      "story": "cxxopts was created to offer a modern, header-only alternative to traditional C++ command-line parsers. It supports optional arguments, default values, boolean flags, and automatic help generation, allowing developers to focus on application logic rather than argument parsing.",
      "installation": {
        "linux": "Download the single header file from https://github.com/jarro2783/cxxopts and include it in your project",
        "mac": "Same as Linux; copy the header into your include path",
        "windows": "Download the header file from GitHub and include it in your project"
      },
      "usage": {
        "overview": "cxxopts allows you to define named options, positional arguments, boolean flags, and automatically generates help messages. It supports both short (`-h`) and long (`--help`) option formats and integrates easily into existing C++ projects.",
        "basic_examples": [
          {
            "title": "Parsing basic options",
            "code": "#include <cxxopts.hpp>\n#include <iostream>\nint main(int argc, char* argv[]) {\n    cxxopts::Options options(\"MyApp\", \"A brief description\");\n    options.add_options()\n        (\"n,name\", \"Name of user\", cxxopts::value<std::string>())\n        (\"h,help\", \"Print help\");\n\n    auto result = options.parse(argc, argv);\n\n    if(result.count(\"help\")) {\n        std::cout << options.help() << std::endl;\n        return 0;\n    }\n\n    if(result.count(\"name\")) {\n        std::cout << \"Hello, \" << result[\"name\"].as<std::string>() << \"!\" << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Defines a `--name` option and `--help` flag, parses command-line arguments, and prints the help or greeting message accordingly."
          },
          {
            "title": "Using default values",
            "code": "#include <cxxopts.hpp>\n#include <iostream>\nint main(int argc, char* argv[]) {\n    cxxopts::Options options(\"MyApp\", \"Demo with defaults\");\n    options.add_options()\n        (\"n,name\", \"Name of user\", cxxopts::value<std::string>()->default_value(\"Guest\"));\n\n    auto result = options.parse(argc, argv);\n    std::cout << \"Hello, \" << result[\"name\"].as<std::string>() << \"!\" << std::endl;\n    return 0;\n}",
            "explanation": "Sets a default value for an option if the user does not provide it."
          }
        ],
        "advanced_examples": [
          {
            "title": "Boolean flags",
            "code": "#include <cxxopts.hpp>\n#include <iostream>\nint main(int argc, char* argv[]) {\n    cxxopts::Options options(\"MyApp\", \"Boolean flags example\");\n    options.add_options()\n        (\"v,verbose\", \"Enable verbose mode\");\n\n    auto result = options.parse(argc, argv);\n    if(result.count(\"verbose\")) {\n        std::cout << \"Verbose mode enabled\" << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Demonstrates using a boolean flag `--verbose` to control program behavior."
          },
          {
            "title": "Positional arguments",
            "code": "#include <cxxopts.hpp>\n#include <iostream>\nint main(int argc, char* argv[]) {\n    cxxopts::Options options(\"MyApp\", \"Positional argument example\");\n    options.add_options()\n        (\"input\", \"Input file\", cxxopts::value<std::string>());\n    options.parse_positional({\"input\"});\n\n    auto result = options.parse(argc, argv);\n    if(result.count(\"input\")) {\n        std::cout << \"Input file: \" << result[\"input\"].as<std::string>() << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Maps positional arguments to named options for easier parsing."
          },
          {
            "title": "Handling exceptions",
            "code": "#include <cxxopts.hpp>\n#include <iostream>\nint main(int argc, char* argv[]) {\n    try {\n        cxxopts::Options options(\"MyApp\", \"Demo\");\n        options.add_options()\n            (\"n,name\", \"Name\", cxxopts::value<std::string>());\n        auto result = options.parse(argc, argv);\n    } catch(const cxxopts::OptionException& e) {\n        std::cerr << \"Error parsing options: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}",
            "explanation": "Catches parsing exceptions to handle invalid or missing arguments gracefully."
          }
        ],
        "best_practices": [
          "Always provide a `--help` option for user convenience.",
          "Use default values for options to simplify usage.",
          "Catch exceptions to prevent application crashes on invalid input.",
          "Document command-line options clearly for end users.",
          "Use named and positional arguments consistently."
        ],
        "error_handling": [
          {
            "error": "cxxopts::OptionException",
            "solution": "Thrown when an invalid option is provided or a required value is missing. Use try-catch blocks to handle gracefully."
          }
        ]
      },
      "references": {
        "official_docs": "https://github.com/jarro2783/cxxopts",
        "github": "https://github.com/jarro2783/cxxopts"
      }
    },
    {
      "id": "range-v3",
      "name": "Range-v3",
      "category": "CLI/Utils",
      "description": "Range-v3 is a C++ library that extends the standard library with a powerful range-based API. It provides composable, lazy-evaluated views and actions on sequences, enabling expressive and functional-style operations on containers and iterators.",
      "story": "Range-v3 was created by Eric Niebler to explore and implement ideas for ranges in C++, many of which were later adopted into C++20. It provides a rich set of algorithms, views, and actions that make working with sequences cleaner and more intuitive compared to traditional iterator-based loops.",
      "installation": {
        "linux": "sudo apt install range-v3-dev",
        "mac": "brew install range-v3",
        "windows": "Download from https://github.com/ericniebler/range-v3 and include headers in your project"
      },
      "usage": {
        "overview": "Range-v3 allows you to create pipelines of range-based operations such as filtering, transforming, and combining sequences. It supports lazy evaluation, composability, and integrates seamlessly with STL containers.",
        "basic_examples": [
          {
            "title": "Filtering a range",
            "code": "#include <range/v3/all.hpp>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> numbers{1,2,3,4,5,6};\n    for(int i : numbers | ranges::views::filter([](int n){ return n % 2 == 0; }))\n        std::cout << i << ' ';\n    return 0;\n}",
            "explanation": "Filters a vector to include only even numbers using a range-based view."
          },
          {
            "title": "Transforming a range",
            "code": "#include <range/v3/all.hpp>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> numbers{1,2,3,4};\n    for(int i : numbers | ranges::views::transform([](int n){ return n * n; }))\n        std::cout << i << ' ';\n    return 0;\n}",
            "explanation": "Transforms a vector by squaring each element using a lazy-evaluated range view."
          }
        ],
        "advanced_examples": [
          {
            "title": "Chaining multiple views",
            "code": "#include <range/v3/all.hpp>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> numbers{1,2,3,4,5,6,7,8,9,10};\n    auto result = numbers\n                  | ranges::views::filter([](int n){ return n % 2 == 0; })\n                  | ranges::views::transform([](int n){ return n * 10; });\n    for(int i : result) std::cout << i << ' ';\n    return 0;\n}",
            "explanation": "Demonstrates chaining multiple range operations (filter + transform) in a clean and readable pipeline."
          },
          {
            "title": "Slicing and dropping elements",
            "code": "#include <range/v3/all.hpp>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> numbers{0,1,2,3,4,5,6,7,8,9};\n    auto result = numbers\n                  | ranges::views::drop(3)\n                  | ranges::views::take(4);\n    for(int i : result) std::cout << i << ' ';\n    return 0;\n}",
            "explanation": "Skips the first 3 elements and takes the next 4 elements using `drop` and `take` views."
          },
          {
            "title": "Combining ranges",
            "code": "#include <range/v3/all.hpp>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> a{1,2,3}, b{4,5,6};\n    auto combined = ranges::views::concat(a, b);\n    for(int i : combined) std::cout << i << ' ';\n    return 0;\n}",
            "explanation": "Concatenates two vectors into a single range without creating a new container."
          },
          {
            "title": "Using action to modify containers",
            "code": "#include <range/v3/all.hpp>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> numbers{1,2,3,4,5};\n    numbers |= ranges::actions::reverse;\n    for(int i : numbers) std::cout << i << ' ';\n    return 0;\n}",
            "explanation": "Reverses a vector in-place using Range-v3 actions."
          }
        ],
        "best_practices": [
          "Prefer lazy views over creating new containers for performance.",
          "Chain views for readable and expressive pipelines.",
          "Use actions when modifying containers in-place.",
          "Combine with STL algorithms where applicable.",
          "Include only the headers you need to reduce compile times."
        ],
        "error_handling": [
          {
            "error": "Compilation errors with iterators",
            "solution": "Ensure your container supports the required iterator category for the view or algorithm used."
          },
          {
            "error": "Concept check failed",
            "solution": "Check that types satisfy the range concepts required by the operations (e.g., input_range, forward_range)."
          }
        ]
      },
      "references": {
        "official_docs": "https://ericniebler.github.io/range-v3/",
        "github": "https://github.com/ericniebler/range-v3"
      }
    },
    {
      "id": "glfw",
      "name": "GLFW",
      "category": "CLI/Utils",
      "description": "GLFW is an open-source library for creating windows, contexts, and handling input and events in OpenGL, OpenGL ES, and Vulkan applications. It is designed to be simple, portable, and lightweight, ideal for graphics and game development.",
      "story": "GLFW was created by Camilla Löwy to provide a simple, cross-platform API for creating windows and managing input in graphics applications. It abstracts platform-specific details and integrates smoothly with OpenGL, making it a popular choice for developers building real-time graphics, games, and simulations.",
      "installation": {
        "linux": "sudo apt install libglfw3-dev",
        "mac": "brew install glfw",
        "windows": "Download precompiled binaries or build from source from https://www.glfw.org/"
      },
      "usage": {
        "overview": "GLFW provides functions to create windows, handle keyboard and mouse input, manage OpenGL or Vulkan contexts, and handle events. It supports multiple monitors, full-screen modes, and high-DPI scaling.",
        "basic_examples": [
          {
            "title": "Creating a simple window",
            "code": "#include <GLFW/glfw3.h>\n#include <iostream>\n\nint main() {\n    if (!glfwInit()) {\n        std::cerr << \"Failed to initialize GLFW\" << std::endl;\n        return -1;\n    }\n\n    GLFWwindow* window = glfwCreateWindow(640, 480, \"Hello GLFW\", nullptr, nullptr);\n    if (!window) {\n        glfwTerminate();\n        return -1;\n    }\n\n    glfwMakeContextCurrent(window);\n\n    while (!glfwWindowShouldClose(window)) {\n        glClear(GL_COLOR_BUFFER_BIT);\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    glfwDestroyWindow(window);\n    glfwTerminate();\n    return 0;\n}",
            "explanation": "Initializes GLFW, creates a 640x480 window, and enters a loop to handle events and update the window until it is closed."
          },
          {
            "title": "Handling keyboard input",
            "code": "void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) {\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\n        glfwSetWindowShouldClose(window, true);\n}\n\nint main() {\n    glfwInit();\n    GLFWwindow* window = glfwCreateWindow(640, 480, \"Input Example\", nullptr, nullptr);\n    glfwMakeContextCurrent(window);\n    glfwSetKeyCallback(window, key_callback);\n\n    while (!glfwWindowShouldClose(window)) {\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n    glfwDestroyWindow(window);\n    glfwTerminate();\n    return 0;\n}",
            "explanation": "Registers a keyboard callback to close the window when the Escape key is pressed."
          }
        ],
        "advanced_examples": [
          {
            "title": "Mouse input handling",
            "code": "void mouse_callback(GLFWwindow* window, double xpos, double ypos) {\n    std::cout << \"Mouse moved to: (\" << xpos << \", \" << ypos << \")\" << std::endl;\n}\n\nint main() {\n    glfwInit();\n    GLFWwindow* window = glfwCreateWindow(640, 480, \"Mouse Example\", nullptr, nullptr);\n    glfwMakeContextCurrent(window);\n    glfwSetCursorPosCallback(window, mouse_callback);\n\n    while (!glfwWindowShouldClose(window)) {\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n    glfwDestroyWindow(window);\n    glfwTerminate();\n    return 0;\n}",
            "explanation": "Tracks mouse movements using a cursor position callback."
          },
          {
            "title": "Full-screen window",
            "code": "GLFWmonitor* primary = glfwGetPrimaryMonitor();\nconst GLFWvidmode* mode = glfwGetVideoMode(primary);\nGLFWwindow* window = glfwCreateWindow(mode->width, mode->height, \"FullScreen\", primary, nullptr);",
            "explanation": "Creates a full-screen window using the primary monitor’s video mode."
          },
          {
            "title": "V-Sync",
            "code": "glfwSwapInterval(1);",
            "explanation": "Enables vertical synchronization to limit the frame rate to the display refresh rate, reducing screen tearing."
          },
          {
            "title": "Handling multiple windows",
            "code": "GLFWwindow* window1 = glfwCreateWindow(400, 300, \"Window 1\", nullptr, nullptr);\nGLFWwindow* window2 = glfwCreateWindow(400, 300, \"Window 2\", nullptr, window1);",
            "explanation": "Demonstrates creating multiple windows with shared OpenGL contexts."
          }
        ],
        "best_practices": [
          "Always call `glfwTerminate()` before exiting to clean up resources.",
          "Use callbacks for input handling rather than polling for cleaner code.",
          "Check return values of GLFW functions to handle initialization or creation errors.",
          "Use `glfwSwapInterval(1)` for smoother rendering.",
          "Keep rendering and event polling in separate loops for responsive UI."
        ],
        "error_handling": [
          {
            "error": "GLFW_NOT_INITIALIZED",
            "solution": "Ensure `glfwInit()` is called successfully before using other GLFW functions."
          },
          {
            "error": "Failed to create GLFW window",
            "solution": "Verify that the requested video mode and context hints are supported by your system."
          },
          {
            "error": "OpenGL context not current",
            "solution": "Call `glfwMakeContextCurrent(window)` before issuing OpenGL commands."
          }
        ]
      },
      "references": {
        "official_docs": "https://www.glfw.org/docs/latest/",
        "github": "https://github.com/glfw/glfw"
      }
    },
    {
      "id": "sfml",
      "name": "SFML",
      "category": "CLI/Utils",
      "description": "SFML (Simple and Fast Multimedia Library) is a multimedia library written in C++ that provides simple APIs for graphics, window management, audio, and networking. It is designed to be user-friendly and portable, ideal for 2D games and multimedia applications.",
      "story": "SFML was created by Laurent Gomila as an alternative to SDL, offering a cleaner C++ object-oriented API for multimedia development. Its modular design allows developers to use only the components they need, such as graphics, audio, or networking, without pulling in unnecessary dependencies.",
      "installation": {
        "linux": "sudo apt install libsfml-dev",
        "mac": "brew install sfml",
        "windows": "Download from https://www.sfml-dev.org/download.php and link libraries in your project"
      },
      "usage": {
        "overview": "SFML provides modules for handling windows, graphics (2D rendering), audio (sound and music), input, and networking. It abstracts platform-specific details, making development portable across systems.",
        "basic_examples": [
          {
            "title": "Creating a window",
            "code": "#include <SFML/Graphics.hpp>\n\nint main() {\n    sf::RenderWindow window(sf::VideoMode(800, 600), \"Hello SFML\");\n\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear();\n        window.display();\n    }\n    return 0;\n}",
            "explanation": "Creates an 800x600 window with an event loop that closes the window when requested."
          },
          {
            "title": "Drawing a shape",
            "code": "#include <SFML/Graphics.hpp>\n\nint main() {\n    sf::RenderWindow window(sf::VideoMode(400, 400), \"Shapes\");\n    sf::CircleShape circle(100);\n    circle.setFillColor(sf::Color::Green);\n\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear();\n        window.draw(circle);\n        window.display();\n    }\n    return 0;\n}",
            "explanation": "Draws a green circle in the window using SFML's 2D graphics module."
          }
        ],
        "advanced_examples": [
          {
            "title": "Handling keyboard input",
            "code": "#include <SFML/Graphics.hpp>\n#include <iostream>\n\nint main() {\n    sf::RenderWindow window(sf::VideoMode(400, 400), \"Keyboard Input\");\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Escape))\n                window.close();\n        }\n    }\n    return 0;\n}",
            "explanation": "Closes the window when the Escape key is pressed."
          },
          {
            "title": "Playing audio",
            "code": "#include <SFML/Audio.hpp>\n#include <iostream>\n\nint main() {\n    sf::SoundBuffer buffer;\n    if (!buffer.loadFromFile(\"sound.wav\")) {\n        std::cerr << \"Error loading sound\" << std::endl;\n        return -1;\n    }\n    sf::Sound sound;\n    sound.setBuffer(buffer);\n    sound.play();\n\n    sf::sleep(sf::seconds(3));\n    return 0;\n}",
            "explanation": "Loads a WAV file and plays it using SFML's audio module."
          },
          {
            "title": "Simple networking (TCP client)",
            "code": "#include <SFML/Network.hpp>\n#include <iostream>\n\nint main() {\n    sf::TcpSocket socket;\n    if (socket.connect(\"example.com\", 53000) != sf::Socket::Done) {\n        std::cerr << \"Failed to connect\" << std::endl;\n    } else {\n        std::cout << \"Connected!\" << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Demonstrates SFML’s networking support by connecting to a TCP server."
          },
          {
            "title": "Loading textures and sprites",
            "code": "#include <SFML/Graphics.hpp>\nint main() {\n    sf::RenderWindow window(sf::VideoMode(800, 600), \"Sprite Example\");\n    sf::Texture texture;\n    texture.loadFromFile(\"sprite.png\");\n    sf::Sprite sprite(texture);\n\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n        window.clear();\n        window.draw(sprite);\n        window.display();\n    }\n    return 0;\n}",
            "explanation": "Loads an image from a file and displays it as a sprite in the window."
          }
        ],
        "best_practices": [
          "Always check return values of resource loading functions (textures, sounds, etc.).",
          "Keep your game loop structured with clear update and render phases.",
          "Use `sf::Clock` for frame timing and animations.",
          "Free unused resources promptly to save memory.",
          "Organize large projects by separating logic, rendering, and input handling."
        ],
        "error_handling": [
          {
            "error": "Resource loading failed",
            "solution": "Check file paths and formats when using `loadFromFile()` for textures, sounds, or fonts."
          },
          {
            "error": "Audio device unavailable",
            "solution": "Ensure the system has a valid sound device and the format is supported."
          },
          {
            "error": "Networking issues",
            "solution": "Verify firewall, server availability, and ports when using SFML’s network module."
          }
        ]
      },
      "references": {
        "official_docs": "https://www.sfml-dev.org/documentation/2.6.0/",
        "github": "https://github.com/SFML/SFML"
      }
    },
    {
      "id": "assimp",
      "name": "Assimp",
      "category": "Graphics/Game Development",
      "description": "Assimp (Open Asset Import Library) is a portable and extensible library that imports and processes 3D models in various formats. It provides a unified API for loading meshes, materials, animations, and scene data from files like OBJ, FBX, COLLADA, and many more.",
      "story": "Assimp was created to address the lack of a standardized way to import 3D assets in graphics and game engines. Instead of writing custom loaders for every file format, developers can rely on Assimp’s robust and extensible API. Today, Assimp supports over 40 3D formats and is widely used in engines, visualization tools, and AR/VR applications.",
      "installation": {
        "linux": "sudo apt install assimp-dev",
        "mac": "brew install assimp",
        "windows": "Download precompiled binaries or build from source at https://github.com/assimp/assimp"
      },
      "usage": {
        "overview": "Assimp simplifies importing 3D models by converting them into a unified in-memory representation. It handles geometry, textures, materials, bones, and animations, making it easy to integrate assets into graphics pipelines or game engines.",
        "basic_examples": [
          {
            "title": "Loading a 3D model",
            "code": "#include <assimp/Importer.hpp>\n#include <assimp/scene.h>\n#include <assimp/postprocess.h>\n#include <iostream>\n\nint main() {\n    Assimp::Importer importer;\n    const aiScene* scene = importer.ReadFile(\"model.obj\",\n        aiProcess_Triangulate | aiProcess_FlipUVs);\n\n    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {\n        std::cerr << \"Error: \" << importer.GetErrorString() << std::endl;\n        return -1;\n    }\n\n    std::cout << \"Model loaded with \" << scene->mNumMeshes << \" meshes.\" << std::endl;\n    return 0;\n}",
            "explanation": "Imports a model from OBJ format, triangulates faces, flips UVs, and prints the number of meshes loaded."
          }
        ],
        "advanced_examples": [
          {
            "title": "Iterating over meshes",
            "code": "for (unsigned int i = 0; i < scene->mNumMeshes; i++) {\n    aiMesh* mesh = scene->mMeshes[i];\n    std::cout << \"Mesh has \" << mesh->mNumVertices << \" vertices.\" << std::endl;\n}",
            "explanation": "Loops through all meshes in the scene and prints vertex counts."
          },
          {
            "title": "Accessing materials",
            "code": "for (unsigned int i = 0; i < scene->mNumMaterials; i++) {\n    aiMaterial* material = scene->mMaterials[i];\n    aiString name;\n    if (material->Get(AI_MATKEY_NAME, name) == AI_SUCCESS)\n        std::cout << \"Material name: \" << name.C_Str() << std::endl;\n}",
            "explanation": "Retrieves material names from the imported model."
          },
          {
            "title": "Loading animations",
            "code": "if (scene->mAnimations != nullptr) {\n    std::cout << \"Model contains \" << scene->mNumAnimations << \" animations.\" << std::endl;\n}",
            "explanation": "Checks and logs if the imported model contains animations."
          },
          {
            "title": "Recursive node traversal",
            "code": "void processNode(aiNode* node, const aiScene* scene) {\n    for (unsigned int i = 0; i < node->mNumMeshes; i++) {\n        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];\n        std::cout << \"Processing mesh with \" << mesh->mNumVertices << \" vertices\" << std::endl;\n    }\n    for (unsigned int i = 0; i < node->mNumChildren; i++) {\n        processNode(node->mChildren[i], scene);\n    }\n}\n\nprocessNode(scene->mRootNode, scene);",
            "explanation": "Traverses the scene graph recursively to process meshes in a hierarchy (useful for game engines)."
          }
        ],
        "best_practices": [
          "Always check the return value of `ReadFile` for errors before accessing the scene.",
          "Use post-processing flags like `aiProcess_Triangulate` and `aiProcess_GenNormals` to simplify mesh data.",
          "Free resources properly by relying on `Assimp::Importer` object lifetime.",
          "Handle missing textures and materials gracefully to avoid crashes.",
          "Cache model data if reusing assets to avoid repeated parsing costs."
        ],
        "error_handling": [
          {
            "error": "AI_SCENE_FLAGS_INCOMPLETE",
            "solution": "Indicates the file was not fully imported. Check the format and ensure proper post-processing flags."
          },
          {
            "error": "Importer.GetErrorString() returns message",
            "solution": "Provides detailed error reasons like unsupported format or corrupt file. Use supported formats like OBJ, FBX, or COLLADA."
          },
          {
            "error": "Null scene pointer",
            "solution": "Occurs if import fails. Verify the file path, extension, and read permissions."
          }
        ]
      },
      "references": {
        "official_docs": "https://assimp-docs.readthedocs.io/",
        "github": "https://github.com/assimp/assimp"
      }
    },
    {
      "id": "bullet",
      "name": "Bullet Physics",
      "category": "Graphics/Game Development",
      "description": "Bullet Physics is a professional-grade physics simulation library for real-time collision detection, rigid body dynamics, soft body dynamics, and vehicle simulation. It is widely used in games, VR, robotics, and film production.",
      "story": "Bullet Physics was created by Erwin Coumans to provide an open-source, high-performance physics engine for real-time applications. It became popular in the gaming industry and is also used in robotics simulations, VR environments, and even Hollywood films. The library is modular, efficient, and integrates well with OpenGL, Vulkan, and game engines.",
      "installation": {
        "linux": "sudo apt install libbullet-dev",
        "mac": "brew install bullet",
        "windows": "Download source or binaries from https://github.com/bulletphysics/bullet3 and build with CMake"
      },
      "usage": {
        "overview": "Bullet provides APIs to simulate physics worlds with rigid bodies, soft bodies, vehicles, and constraints. It includes a broad-phase collision detection system, efficient solvers, and supports GPU acceleration via OpenCL.",
        "basic_examples": [
          {
            "title": "Hello World physics simulation",
            "code": "#include <btBulletDynamicsCommon.h>\n#include <iostream>\n\nint main() {\n    // Broadphase\n    btBroadphaseInterface* broadphase = new btDbvtBroadphase();\n\n    // Collision configuration and dispatcher\n    btDefaultCollisionConfiguration* collisionConfig = new btDefaultCollisionConfiguration();\n    btCollisionDispatcher* dispatcher = new btCollisionDispatcher(collisionConfig);\n\n    // Solver\n    btSequentialImpulseConstraintSolver* solver = new btSequentialImpulseConstraintSolver;\n\n    // Dynamics world\n    btDiscreteDynamicsWorld* dynamicsWorld = new btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfig);\n    dynamicsWorld->setGravity(btVector3(0, -9.81f, 0));\n\n    // Ground plane\n    btCollisionShape* groundShape = new btStaticPlaneShape(btVector3(0, 1, 0), 1);\n    btDefaultMotionState* groundMotionState = new btDefaultMotionState(btTransform(btQuaternion(0,0,0,1), btVector3(0,-1,0)));\n    btRigidBody::btRigidBodyConstructionInfo groundRigidBodyCI(0, groundMotionState, groundShape, btVector3(0,0,0));\n    btRigidBody* groundRigidBody = new btRigidBody(groundRigidBodyCI);\n    dynamicsWorld->addRigidBody(groundRigidBody);\n\n    // Falling sphere\n    btCollisionShape* sphereShape = new btSphereShape(1);\n    btDefaultMotionState* sphereMotionState = new btDefaultMotionState(btTransform(btQuaternion(0,0,0,1), btVector3(0,50,0)));\n    btScalar mass = 1;\n    btVector3 inertia(0,0,0);\n    sphereShape->calculateLocalInertia(mass, inertia);\n    btRigidBody::btRigidBodyConstructionInfo sphereRigidBodyCI(mass, sphereMotionState, sphereShape, inertia);\n    btRigidBody* sphereRigidBody = new btRigidBody(sphereRigidBodyCI);\n    dynamicsWorld->addRigidBody(sphereRigidBody);\n\n    // Simulation loop\n    for (int i=0; i<300; i++) {\n        dynamicsWorld->stepSimulation(1/60.f, 10);\n        btTransform trans;\n        sphereRigidBody->getMotionState()->getWorldTransform(trans);\n        std::cout << \"Sphere height: \" << trans.getOrigin().getY() << std::endl;\n    }\n\n    // Cleanup\n    delete dynamicsWorld;\n    delete solver;\n    delete dispatcher;\n    delete collisionConfig;\n    delete broadphase;\n\n    return 0;\n}",
            "explanation": "Creates a simple world with gravity, a ground plane, and a falling sphere simulated in Bullet Physics."
          }
        ],
        "advanced_examples": [
          {
            "title": "Adding constraints",
            "code": "btHingeConstraint* hinge = new btHingeConstraint(*bodyA, *bodyB, pivotInA, pivotInB, axisInA, axisInB);\ndynamicsWorld->addConstraint(hinge);",
            "explanation": "Adds a hinge constraint between two rigid bodies, simulating joints like doors or elbows."
          },
          {
            "title": "Soft body simulation",
            "code": "btSoftBody* softBody = btSoftBodyHelpers::CreateRope(worldInfo, btVector3(0,10,0), btVector3(10,10,0), 8, 1);\ndynamicsWorld->addSoftBody(softBody);",
            "explanation": "Creates a rope-like soft body simulation using Bullet’s soft body module."
          },
          {
            "title": "Vehicle simulation",
            "code": "btRaycastVehicle::btVehicleTuning tuning;\nbtRaycastVehicle* vehicle = new btRaycastVehicle(tuning, chassis, raycaster);\ndynamicsWorld->addVehicle(vehicle);",
            "explanation": "Demonstrates how to simulate a vehicle with wheels and suspension in Bullet."
          },
          {
            "title": "Using GPU acceleration",
            "code": "// Requires Bullet built with OpenCL support\n// Use btOpenCLSoftBodySolver for GPU-accelerated soft body simulation",
            "explanation": "Enables GPU acceleration for large-scale simulations when Bullet is compiled with OpenCL."
          }
        ],
        "best_practices": [
          "Use appropriate collision shapes (box, sphere, convex hull) for performance over exact meshes.",
          "Always call `stepSimulation` with a fixed timestep for stable results.",
          "Release memory carefully to avoid leaks in complex scenes.",
          "Use constraints sparingly; too many can hurt performance.",
          "Profile and optimize for broadphase vs narrowphase collision detection."
        ],
        "error_handling": [
          {
            "error": "Objects fall through the floor",
            "solution": "Ensure collision shapes are set correctly and the ground plane is added as a static rigid body."
          },
          {
            "error": "Simulation instability",
            "solution": "Use smaller timesteps, increase solver iterations, or simplify collision geometry."
          },
          {
            "error": "High memory usage",
            "solution": "Remove unused rigid bodies and shapes, and reuse collision shapes across multiple objects."
          }
        ]
      },
      "references": {
        "official_docs": "https://pybullet.org/Bullet/BulletFull/",
        "github": "https://github.com/bulletphysics/bullet3"
      }
    },
    {
      "id": "ogre",
      "name": "OGRE",
      "category": "Graphics/Game Development",
      "description": "OGRE (Object-Oriented Graphics Rendering Engine) is a scene-oriented, flexible 3D rendering engine written in C++. It abstracts low-level graphics APIs like OpenGL and Direct3D, providing a high-level interface for rendering 3D graphics in applications such as games, simulations, and visualizations.",
      "story": "OGRE was first released in 2001 as an open-source project to make 3D rendering more accessible. Instead of writing raw OpenGL/Direct3D code, developers could use OGRE’s scene graph, material system, and resource management features. Over the years, OGRE became popular in indie games, simulators, and research projects as a lightweight alternative to full game engines.",
      "installation": {
        "linux": "sudo apt install libogre-1.9-dev",
        "mac": "brew install ogre",
        "windows": "Download from https://www.ogre3d.org/download/sdk or build from source on GitHub"
      },
      "usage": {
        "overview": "OGRE provides a scene graph structure, materials, shaders, and resource management for real-time 3D rendering. It is highly extensible with plugins and can be integrated with physics engines (Bullet, ODE) and input libraries (SDL2, OIS).",
        "basic_examples": [
          {
            "title": "Initializing OGRE and creating a window",
            "code": "#include <Ogre.h>\n\nint main() {\n    Ogre::Root* root = new Ogre::Root();\n\n    if (!root->restoreConfig() && !root->showConfigDialog()) {\n        return -1; // User canceled config\n    }\n\n    Ogre::RenderWindow* window = root->initialise(true, \"OGRE Window\");\n\n    Ogre::SceneManager* sceneMgr = root->createSceneManager(Ogre::ST_GENERIC);\n    Ogre::Camera* cam = sceneMgr->createCamera(\"MainCam\");\n    Ogre::Viewport* vp = window->addViewport(cam);\n\n    root->startRendering();\n    delete root;\n    return 0;\n}",
            "explanation": "Creates a simple OGRE rendering window with a camera and viewport."
          }
        ],
        "advanced_examples": [
          {
            "title": "Loading a mesh",
            "code": "Ogre::Entity* entity = sceneMgr->createEntity(\"ogrehead.mesh\");\nOgre::SceneNode* node = sceneMgr->getRootSceneNode()->createChildSceneNode();\nnode->attachObject(entity);",
            "explanation": "Loads a 3D model (mesh) and attaches it to the scene graph."
          },
          {
            "title": "Adding lights",
            "code": "Ogre::Light* light = sceneMgr->createLight(\"MainLight\");\nlight->setType(Ogre::Light::LT_DIRECTIONAL);\nlight->setDirection(Ogre::Vector3(-1, -1, -1));",
            "explanation": "Adds a directional light to illuminate the scene."
          },
          {
            "title": "Using materials",
            "code": "entity->setMaterialName(\"Examples/Rockwall\");",
            "explanation": "Applies a predefined material to a mesh."
          },
          {
            "title": "Scene graph traversal",
            "code": "Ogre::SceneNode* childNode = node->createChildSceneNode(Ogre::Vector3(10,0,0));",
            "explanation": "Adds a child node to the scene graph to manage hierarchical transformations."
          }
        ],
        "best_practices": [
          "Use the scene graph for hierarchical transformations instead of manually managing matrices.",
          "Leverage OGRE’s resource system for managing meshes, textures, and shaders.",
          "Integrate with physics libraries (e.g., Bullet, ODE) for interactive simulations.",
          "Prefer hardware-accelerated materials and shaders for better performance.",
          "Organize assets into resource groups for efficient loading."
        ],
        "error_handling": [
          {
            "error": "Render window fails to open",
            "solution": "Check graphics driver compatibility and ensure correct OpenGL/DirectX support."
          },
          {
            "error": "Mesh not found",
            "solution": "Verify resource paths in OGRE’s resources.cfg file."
          },
          {
            "error": "Shader compilation errors",
            "solution": "Ensure correct GLSL/HLSL versions and use OGRE’s material scripting system."
          }
        ]
      },
      "references": {
        "official_docs": "https://ogrecave.github.io/ogre/api/latest/",
        "github": "https://github.com/OGRECave/ogre"
      }
    },
    {
      "id": "magnum",
      "name": "Magnum",
      "category": "Graphics/Game Development",
      "description": "Magnum is a lightweight and modular C++11/C++14 graphics middleware for 2D and 3D graphics, game development, and visualization. It builds on top of modern OpenGL, Vulkan, and WebGPU APIs, offering a clean, extensible framework for rendering, math, input, and asset management.",
      "story": "Magnum was created to provide a modern, minimal, and modular alternative to large 3D engines like OGRE or Unity. It focuses on C++ developers who want direct control over the rendering pipeline but also appreciate high-level abstractions for graphics, math, and resource handling. With its modular design, Magnum can be used for game engines, VR/AR, embedded systems, and scientific visualization.",
      "installation": {
        "linux": "sudo apt install corrade-dev magnum-dev magnum-plugins-dev",
        "mac": "brew install mosra/magnum/magnum",
        "windows": "Download or build from source at https://github.com/mosra/magnum (CMake-based)"
      },
      "usage": {
        "overview": "Magnum provides rendering backends (OpenGL, Vulkan), math utilities, a plugin-based asset system, input handling, and integrations with libraries like SDL2, GLFW, and ImGui. Developers can use only the modules they need thanks to its modular architecture.",
        "basic_examples": [
          {
            "title": "Creating a window with OpenGL context",
            "code": "#include <Magnum/GL/DefaultFramebuffer.h>\n#include <Magnum/Platform/Sdl2Application.h>\n\nusing namespace Magnum;\n\nclass MyApp: public Platform::Application {\n    public:\n        explicit MyApp(const Arguments& arguments): Platform::Application{arguments} {}\n\n        void drawEvent() override {\n            GL::defaultFramebuffer.clear(GL::FramebufferClear::Color);\n            swapBuffers();\n        }\n};\n\nMAGNUM_APPLICATION_MAIN(MyApp)",
            "explanation": "Creates a basic window with an OpenGL context using Magnum’s SDL2 platform integration."
          }
        ],
        "advanced_examples": [
          {
            "title": "Rendering a triangle",
            "code": "// Define vertex buffer, shader, and draw a triangle\n// Uses Magnum::GL::Buffer, Magnum::Shaders::Flat, and Magnum::Mesh",
            "explanation": "Magnum provides modern abstractions for vertex buffers, shaders, and meshes, simplifying OpenGL rendering."
          },
          {
            "title": "Loading textures via plugins",
            "code": "Trade::AnyImageImporter importer;\nif(importer.openFile(\"texture.png\")) {\n    GL::Texture2D texture;\n    texture.setStorage(1, GL::TextureFormat::RGBA8, importer.image2D(0)->size());\n    texture.setSubImage(0, {}, *importer.image2D(0));\n}",
            "explanation": "Loads an image using Magnum’s plugin system and uploads it to an OpenGL texture."
          },
          {
            "title": "Using math utilities",
            "code": "Matrix4 transformation = Matrix4::translation({1.0f, 2.0f, 3.0f}) * Matrix4::scaling(Vector3{2.0f});",
            "explanation": "Magnum includes a fast and type-safe math library for transformations and linear algebra."
          },
          {
            "title": "Integration with ImGui",
            "code": "// Magnum provides ImGuiIntegration::Context for debug UIs",
            "explanation": "Easily integrate Dear ImGui into Magnum apps for GUI overlays."
          }
        ],
        "best_practices": [
          "Use Magnum modules selectively; don’t include everything if you only need math or asset loaders.",
          "Prefer Magnum’s math library over raw OpenGL math handling for safety and clarity.",
          "Use plugins for image, audio, and model loading instead of writing custom parsers.",
          "Leverage Vulkan backend for modern rendering pipelines when possible.",
          "Integrate with SDL2 or GLFW for platform and input management."
        ],
        "error_handling": [
          {
            "error": "OpenGL context creation failure",
            "solution": "Ensure proper GPU drivers are installed and platform integration (SDL2/GLFW) is configured correctly."
          },
          {
            "error": "Plugin not found",
            "solution": "Install Magnum plugins package or ensure plugins are in the correct runtime path."
          },
          {
            "error": "Shader compilation errors",
            "solution": "Verify GLSL versions and use Magnum’s shader classes for safer abstraction."
          }
        ]
      },
      "references": {
        "official_docs": "https://doc.magnum.graphics/",
        "github": "https://github.com/mosra/magnum"
      }
    },
    {
      "id": "dlib",
      "name": "dlib",
      "category": "Machine Learning",
      "description": "dlib is a modern C++ toolkit containing machine learning algorithms and tools for creating complex software in computer vision, image processing, facial recognition, natural language processing, and general-purpose machine learning.",
      "story": "dlib was created by Davis King in 2002 as an open-source C++ library to provide practical implementations of state-of-the-art machine learning algorithms. Over time, it expanded to include image processing, facial recognition, numerical optimization, and deep learning capabilities. dlib is widely used in academia, research, and industry, especially for face detection and recognition tasks.",
      "installation": {
        "linux": "sudo apt install libdlib-dev",
        "mac": "brew install dlib",
        "windows": "Install via vcpkg: vcpkg install dlib or build from source with CMake"
      },
      "usage": {
        "overview": "dlib provides machine learning algorithms (SVMs, k-means, neural networks), numerical optimization, image processing, and deep learning tools. It includes pre-trained models for facial recognition and object detection.",
        "basic_examples": [
          {
            "title": "Face detection with dlib",
            "code": "#include <dlib/image_processing/frontal_face_detector.h>\n#include <dlib/image_io.h>\n#include <iostream>\n\nint main() {\n    dlib::frontal_face_detector detector = dlib::get_frontal_face_detector();\n    dlib::array2d<unsigned char> img;\n    dlib::load_image(img, \"face.jpg\");\n\n    std::vector<dlib::rectangle> faces = detector(img);\n    std::cout << \"Detected \" << faces.size() << \" faces.\" << std::endl;\n    return 0;\n}",
            "explanation": "Loads an image and detects human faces using dlib’s pre-trained frontal face detector."
          }
        ],
        "advanced_examples": [
          {
            "title": "Facial landmark detection",
            "code": "dlib::shape_predictor sp;\ndlib::deserialize(\"shape_predictor_68_face_landmarks.dat\") >> sp;\nauto shape = sp(img, faces[0]);",
            "explanation": "Uses a pre-trained model to detect 68 facial landmarks (eyes, nose, mouth, jawline)."
          },
          {
            "title": "Face recognition",
            "code": "dlib::anet_type net;\ndlib::deserialize(\"dlib_face_recognition_resnet_model_v1.dat\") >> net;\ndlib::matrix<dlib::rgb_pixel> face_chip;\ndlib::extract_image_chip(img, dlib::get_face_chip_details(shape,150,0.25), face_chip);\nauto face_descriptor = net(face_chip);",
            "explanation": "Computes a 128D vector embedding for a detected face, useful for face recognition and comparison."
          },
          {
            "title": "Training an SVM classifier",
            "code": "dlib::svm_c_trainer<kernel_type> trainer;\nauto learned_function = trainer.train(samples, labels);",
            "explanation": "dlib includes traditional ML algorithms like SVMs for supervised learning."
          },
          {
            "title": "Using deep learning",
            "code": "// dlib provides a deep learning API built on top of cuDNN for defining custom CNN architectures",
            "explanation": "Supports defining, training, and deploying convolutional neural networks with GPU acceleration."
          }
        ],
        "best_practices": [
          "Use pre-trained models for face detection and recognition instead of training from scratch.",
          "Leverage GPU acceleration (cuDNN, CUDA) when using dlib’s deep learning features.",
          "Prefer dlib’s image processing for lightweight tasks instead of full CV frameworks if speed is important.",
          "Use dlib in combination with OpenCV for extended functionality (I/O, video streams).",
          "Normalize face embeddings before comparing for recognition tasks."
        ],
        "error_handling": [
          {
            "error": "deserialize() file not found",
            "solution": "Ensure pre-trained model files (.dat) are downloaded and available in the correct path."
          },
          {
            "error": "CUDA errors",
            "solution": "Verify CUDA and cuDNN installations when using GPU features."
          },
          {
            "error": "Slow performance on CPU",
            "solution": "Enable AVX/SSE instructions or use GPU acceleration for heavy computations."
          }
        ]
      },
      "references": {
        "official_docs": "http://dlib.net/",
        "github": "https://github.com/davisking/dlib"
      }
    },
    {
      "id": "armadillo",
      "name": "Armadillo",
      "category": "Machine Learning",
      "description": "Armadillo is a high-quality C++ linear algebra library that provides efficient matrix and vector operations, while offering a syntax similar to MATLAB. It is designed for both speed and ease of use, making it popular in scientific computing, machine learning, and signal processing.",
      "story": "Armadillo was created to bridge the gap between high-performance C++ libraries (like BLAS and LAPACK) and user-friendly numerical software like MATLAB. It provides a natural, concise API for expressing mathematical operations while relying on optimized backends (e.g., Intel MKL, OpenBLAS, LAPACK) for performance. It has become a standard tool in research, academia, and industries requiring numerical simulations and machine learning.",
      "installation": {
        "linux": "sudo apt install libarmadillo-dev",
        "mac": "brew install armadillo",
        "windows": "vcpkg install armadillo or build from source at http://arma.sourceforge.net/download.html"
      },
      "usage": {
        "overview": "Armadillo supports dense and sparse matrices, vectors, linear algebra, statistics, eigendecompositions, and integration with LAPACK/BLAS backends. Its MATLAB-like syntax makes it accessible to researchers migrating to C++.",
        "basic_examples": [
          {
            "title": "Matrix multiplication",
            "code": "#include <armadillo>\n#include <iostream>\n\nint main() {\n    arma::mat A = {{1, 2}, {3, 4}};\n    arma::mat B = {{5, 6}, {7, 8}};\n    arma::mat C = A * B;\n\n    C.print(\"Result of A*B:\");\n    return 0;\n}",
            "explanation": "Performs matrix multiplication using Armadillo with a concise MATLAB-like syntax."
          }
        ],
        "advanced_examples": [
          {
            "title": "Solving linear systems",
            "code": "arma::vec x = arma::solve(A, b);",
            "explanation": "Solves the system of linear equations Ax = b efficiently."
          },
          {
            "title": "Eigen decomposition",
            "code": "arma::vec eigval;\narma::mat eigvec;\narma::eig_sym(eigval, eigvec, A);",
            "explanation": "Computes eigenvalues and eigenvectors of a symmetric matrix."
          },
          {
            "title": "Singular value decomposition (SVD)",
            "code": "arma::mat U, V;\narma::vec s;\narma::svd(U, s, V, A);",
            "explanation": "Computes the SVD decomposition of a matrix."
          },
          {
            "title": "Using sparse matrices",
            "code": "arma::sp_mat S(1000, 1000);\nS(0,0) = 1.5;\nS(100,200) = 2.3;",
            "explanation": "Efficiently handles large sparse matrices with minimal memory overhead."
          }
        ],
        "best_practices": [
          "Use Armadillo’s high-level syntax for readability, but enable optimized BLAS/LAPACK backends for performance.",
          "Use `arma::sp_mat` for sparse matrices to save memory in large datasets.",
          "Call `.t()` for transpose instead of manually looping.",
          "Avoid unnecessary copies by using Armadillo’s lazy evaluation (`.eval()` when needed).",
          "Prefer built-in solvers over manually implementing algorithms."
        ],
        "error_handling": [
          {
            "error": "Runtime error: matrix singular",
            "solution": "Occurs when trying to solve a system with a singular matrix. Ensure the matrix is invertible or use pseudo-inverse."
          },
          {
            "error": "Linker errors with LAPACK/BLAS",
            "solution": "Ensure you link with `-llapack -lblas` or have OpenBLAS/Intel MKL installed."
          },
          {
            "error": "Slow performance",
            "solution": "Install optimized BLAS/LAPACK backends instead of relying on the default implementation."
          }
        ]
      },
      "references": {
        "official_docs": "http://arma.sourceforge.net/docs.html",
        "github": "https://gitlab.com/conradsnicta/armadillo-code"
      }
    },
    {
      "id": "mlpack",
      "name": "MLPack",
      "category": "Machine Learning",
      "description": "MLPack is a fast, flexible, and scalable C++ machine learning library. It provides a wide range of machine learning algorithms and data science tools with a focus on high performance and ease of use, while also offering bindings for Python, Julia, and other languages.",
      "story": "MLPack was first released in 2011 as a high-performance machine learning library written in C++. Its design philosophy focuses on speed, scalability, and clean API design. Built on top of Armadillo for linear algebra, MLPack is used in academia and industry for research and production, providing algorithms ranging from classification and regression to deep learning and clustering.",
      "installation": {
        "linux": "sudo apt install libmlpack-dev",
        "mac": "brew install mlpack",
        "windows": "vcpkg install mlpack or build from source using CMake"
      },
      "usage": {
        "overview": "MLPack provides supervised learning (decision trees, logistic regression, random forests), unsupervised learning (k-means, EM clustering), deep learning, reinforcement learning, dimensionality reduction, and optimization algorithms.",
        "basic_examples": [
          {
            "title": "K-means clustering",
            "code": "#include <mlpack/methods/kmeans/kmeans.hpp>\n#include <armadillo>\n#include <iostream>\n\nint main() {\n    arma::mat data;\n    data.load(\"data.csv\");\n\n    mlpack::kmeans::KMeans<> k;\n    arma::Row<size_t> assignments;\n    k.Cluster(data, 3, assignments);\n\n    assignments.print(\"Cluster assignments:\");\n    return 0;\n}",
            "explanation": "Loads data from CSV, runs k-means clustering with 3 clusters, and prints assignments."
          }
        ],
        "advanced_examples": [
          {
            "title": "Logistic regression",
            "code": "#include <mlpack/methods/logistic_regression/logistic_regression.hpp>\n\nmlpack::regression::LogisticRegression<> lr(trainData, trainLabels, 0.5);\narma::Row<size_t> predictions;\nlr.Classify(testData, predictions);",
            "explanation": "Trains a logistic regression model and uses it to classify test data."
          },
          {
            "title": "Random forest classifier",
            "code": "#include <mlpack/methods/random_forest/random_forest.hpp>\n\nmlpack::tree::RandomForest<> rf(trainData, trainLabels, 10, 5);\narma::Row<size_t> results;\nrf.Classify(testData, results);",
            "explanation": "Trains a random forest with 10 trees and depth 5."
          },
          {
            "title": "Principal Component Analysis (PCA)",
            "code": "#include <mlpack/methods/pca/pca.hpp>\n\nmlpack::pca::PCA pca;\narma::mat transformed;\npca.Apply(data, transformed, 2);",
            "explanation": "Reduces data dimensions from N to 2 using PCA."
          },
          {
            "title": "Reinforcement learning (DQN)",
            "code": "// mlpack provides deep reinforcement learning APIs like DQN and policy gradients",
            "explanation": "Supports reinforcement learning algorithms for training agents in environments."
          }
        ],
        "best_practices": [
          "Use Armadillo matrices as input/output since MLPack is built on top of Armadillo.",
          "Scale and normalize datasets before training ML models.",
          "Use parallelism (OpenMP) for large datasets to improve performance.",
          "Leverage MLPack’s command-line tools (`mlpack_knn`, `mlpack_kmeans`) for quick experiments before coding.",
          "Choose appropriate regularization parameters to prevent overfitting in supervised models."
        ],
        "error_handling": [
          {
            "error": "arma::mat load failure",
            "solution": "Ensure the dataset file exists and is in a valid format (CSV/TSV/Armadillo binary)."
          },
          {
            "error": "Model convergence issues",
            "solution": "Adjust hyperparameters such as learning rate, iterations, or regularization strength."
          },
          {
            "error": "High memory usage",
            "solution": "Use sparse matrix types (`arma::sp_mat`) when working with sparse data."
          }
        ]
      },
      "references": {
        "official_docs": "https://www.mlpack.org/doc/stable/",
        "github": "https://github.com/mlpack/mlpack"
      }
    },
    {
      "id": "caffe",
      "name": "Caffe",
      "category": "Machine Learning",
      "description": "Caffe is a deep learning framework made with expression, speed, and modularity in mind. Written in C++, it provides a clean architecture for defining, training, and deploying deep neural networks, with bindings for Python and MATLAB.",
      "story": "Caffe was developed by Yangqing Jia at the Berkeley Vision and Learning Center (BVLC) in 2013. It quickly became popular for its performance and ease of defining neural networks through configuration files rather than code. Although frameworks like TensorFlow and PyTorch have since become more dominant, Caffe remains widely used in research and production, especially in computer vision applications.",
      "installation": {
        "linux": "sudo apt install caffe-cpu-dev  # For CPU-only version\n# Or build from source with CUDA for GPU support",
        "mac": "brew install caffe",
        "windows": "Build from source with CMake and Visual Studio (official Windows builds are limited)"
      },
      "usage": {
        "overview": "Caffe supports convolutional neural networks (CNNs), recurrent networks (via extensions), and transfer learning. Models are defined in `.prototxt` configuration files and trained using `.caffemodel` weights.",
        "basic_examples": [
          {
            "title": "Classifying an image",
            "code": "#include <caffe/caffe.hpp>\nusing namespace caffe;\n\nint main() {\n    Caffe::set_mode(Caffe::CPU);\n\n    Net<float> net(\"deploy.prototxt\", TEST);\n    net.CopyTrainedLayersFrom(\"bvlc_reference.caffemodel\");\n\n    // Load image and preprocess...\n    // Forward pass through network\n    net.Forward();\n\n    return 0;\n}",
            "explanation": "Loads a pre-trained Caffe model and runs inference on input data."
          }
        ],
        "advanced_examples": [
          {
            "title": "Training a CNN",
            "code": "caffe train --solver=solver.prototxt",
            "explanation": "Trains a CNN using a solver configuration file that defines optimization parameters."
          },
          {
            "title": "Defining a network in Prototxt",
            "code": "layer {\n  name: \"conv1\"\n  type: \"Convolution\"\n  bottom: \"data\"\n  top: \"conv1\"\n  convolution_param {\n    num_output: 96\n    kernel_size: 11\n    stride: 4\n  }\n}",
            "explanation": "Defines a convolutional layer in Caffe’s prototxt format."
          },
          {
            "title": "Using GPU mode",
            "code": "Caffe::set_mode(Caffe::GPU);\nCaffe::SetDevice(0);",
            "explanation": "Runs training or inference on GPU instead of CPU."
          },
          {
            "title": "Fine-tuning a pre-trained model",
            "code": "caffe train --solver=solver.prototxt --weights pretrained.caffemodel",
            "explanation": "Starts training from a pre-trained model for transfer learning."
          }
        ],
        "best_practices": [
          "Use prototxt files for defining architectures instead of hardcoding networks.",
          "Leverage pre-trained models from the Caffe Model Zoo for transfer learning.",
          "Normalize and preprocess images before feeding them into CNNs.",
          "Use GPU mode for training large models, as CPU-only mode is much slower.",
          "Prefer newer frameworks like PyTorch or TensorFlow for modern deep learning projects, but Caffe remains useful for legacy models."
        ],
        "error_handling": [
          {
            "error": "Check failed: !param_file.empty()",
            "solution": "Ensure solver.prototxt and network prototxt files exist and paths are correct."
          },
          {
            "error": "CUDA driver version mismatch",
            "solution": "Update CUDA/cuDNN drivers to match your installed version."
          },
          {
            "error": "Memory allocation failed",
            "solution": "Reduce batch size or use a GPU with more VRAM."
          }
        ]
      },
      "references": {
        "official_docs": "https://caffe.berkeleyvision.org/",
        "github": "https://github.com/BVLC/caffe"
      }
    },
    {
      "id": "soci",
      "name": "SOCI",
      "category": "Database",
      "description": "SOCI is a C++ database access library that provides a clean, type-safe, and object-oriented abstraction over SQL databases. It acts like a lightweight ORM but retains full SQL control, offering both simplicity and flexibility.",
      "story": "SOCI (The C++ Database Access Library) was started in 2004 by Maciej Sobczak to provide a modern alternative to traditional C database APIs like ODBC and libpq. It focuses on safety, readability, and minimal boilerplate while avoiding the complexity of full ORM frameworks. It supports multiple backends including PostgreSQL, MySQL, SQLite, Oracle, and ODBC.",
      "installation": {
        "linux": "sudo apt install libsoci-dev",
        "mac": "brew install soci",
        "windows": "vcpkg install soci or build from source with CMake"
      },
      "usage": {
        "overview": "SOCI allows developers to write queries in natural SQL while providing type-safe bindings to C++ variables. It eliminates manual binding and fetching of data, making database interaction safer and cleaner.",
        "basic_examples": [
          {
            "title": "Connecting to a database",
            "code": "#include <soci/soci.h>\n#include <iostream>\n\nint main() {\n    try {\n        soci::session sql(soci::postgresql, \"dbname=mydb user=myuser password=mypass\");\n        std::cout << \"Connected successfully!\" << std::endl;\n    } catch (std::exception const &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Opens a connection to a PostgreSQL database using SOCI."
          }
        ],
        "advanced_examples": [
          {
            "title": "Executing queries",
            "code": "int count;\nsql << \"SELECT COUNT(*) FROM users\", soci::into(count);\nstd::cout << \"User count: \" << count << std::endl;",
            "explanation": "Executes a query and stores the result directly into a C++ variable."
          },
          {
            "title": "Fetching multiple rows",
            "code": "soci::rowset<soci::row> rs = (sql.prepare << \"SELECT id, name FROM users\");\nfor (auto const &r : rs) {\n    int id = r.get<int>(0);\n    std::string name = r.get<std::string>(1);\n    std::cout << id << \": \" << name << std::endl;\n}",
            "explanation": "Iterates over query results using SOCI’s rowset abstraction."
          },
          {
            "title": "Binding parameters",
            "code": "std::string name = \"John\";\nint age;\nsql << \"SELECT age FROM users WHERE name = :name\", soci::into(age), soci::use(name);",
            "explanation": "Binds C++ variables safely to SQL query parameters."
          },
          {
            "title": "Transactions",
            "code": "{\n    soci::transaction tr(sql);\n    sql << \"INSERT INTO logs(message) VALUES('test')\";\n    tr.commit();\n}",
            "explanation": "Executes queries inside a transaction with explicit commit or rollback."
          }
        ],
        "best_practices": [
          "Use parameter binding (`soci::use`) to avoid SQL injection.",
          "Wrap multiple statements in transactions for safety and efficiency.",
          "Catch exceptions from SOCI queries to handle runtime errors gracefully.",
          "Use `rowset` for large result sets to stream data instead of loading all at once.",
          "Leverage backend-specific options (e.g., PostgreSQL vs MySQL) for performance tuning."
        ],
        "error_handling": [
          {
            "error": "soci_error: Cannot establish connection",
            "solution": "Check database credentials, network connectivity, and that the backend driver is installed."
          },
          {
            "error": "Row not found exception",
            "solution": "Use `sql.get_single_result()` cautiously or check for empty results before accessing."
          },
          {
            "error": "Type conversion error",
            "solution": "Ensure correct C++ types are mapped to SQL columns (e.g., `int` to INTEGER, `std::string` to TEXT)."
          }
        ]
      },
      "references": {
        "official_docs": "http://soci.sourceforge.net/doc/master/",
        "github": "https://github.com/SOCI/soci"
      }
    },
    {
      "id": "rocksdb",
      "name": "RocksDB",
      "category": "Database",
      "description": "RocksDB is an embeddable, high-performance, persistent key-value store developed by Facebook. It is based on LevelDB but optimized for fast storage, low-latency access, and high throughput on flash drives and SSDs.",
      "story": "RocksDB was developed at Facebook in 2012 to handle data-intensive applications that required low-latency and high-throughput storage. Built on Google’s LevelDB, it was enhanced with features like column families, transactions, bloom filters, and better multi-threading. Today, it powers large-scale systems at Facebook, LinkedIn, and other enterprises.",
      "installation": {
        "linux": "sudo apt install librocksdb-dev",
        "mac": "brew install rocksdb",
        "windows": "vcpkg install rocksdb or build from source with CMake"
      },
      "usage": {
        "overview": "RocksDB provides an API for storing and retrieving key-value pairs, supporting advanced features like column families, snapshots, iterators, batch writes, and transactions. It is designed for write-heavy workloads.",
        "basic_examples": [
          {
            "title": "Opening a database and writing data",
            "code": "#include <rocksdb/db.h>\n#include <iostream>\n\nint main() {\n    rocksdb::DB* db;\n    rocksdb::Options options;\n    options.create_if_missing = true;\n\n    rocksdb::Status status = rocksdb::DB::Open(options, \"testdb\", &db);\n    if (!status.ok()) {\n        std::cerr << status.ToString() << std::endl;\n        return 1;\n    }\n\n    status = db->Put(rocksdb::WriteOptions(), \"key1\", \"value1\");\n    std::cout << \"Write Status: \" << status.ToString() << std::endl;\n\n    delete db;\n    return 0;\n}",
            "explanation": "Creates a RocksDB database, writes a key-value pair, and closes it."
          }
        ],
        "advanced_examples": [
          {
            "title": "Reading data",
            "code": "std::string value;\nstatus = db->Get(rocksdb::ReadOptions(), \"key1\", &value);\nif (status.ok()) std::cout << \"Value: \" << value << std::endl;",
            "explanation": "Reads the value of a key from the database."
          },
          {
            "title": "Batch writes",
            "code": "rocksdb::WriteBatch batch;\nbatch.Put(\"key2\", \"value2\");\nbatch.Delete(\"key1\");\ndb->Write(rocksdb::WriteOptions(), &batch);",
            "explanation": "Performs multiple operations in a single atomic batch."
          },
          {
            "title": "Using iterators",
            "code": "rocksdb::Iterator* it = db->NewIterator(rocksdb::ReadOptions());\nfor (it->SeekToFirst(); it->Valid(); it->Next()) {\n    std::cout << it->key().ToString() << \" => \" << it->value().ToString() << std::endl;\n}\ndelete it;",
            "explanation": "Iterates through all key-value pairs in the database."
          },
          {
            "title": "Transactions",
            "code": "rocksdb::TransactionDB* txn_db;\nrocksdb::TransactionDBOptions txn_options;\nrocksdb::DBOptions db_options;\ndb_options.create_if_missing = true;\nrocksdb::TransactionDB::Open(db_options, txn_options, \"testdb_txn\", &txn_db);",
            "explanation": "Opens RocksDB in transaction mode for ACID-compliant operations."
          },
          {
            "title": "Column Families",
            "code": "std::vector<rocksdb::ColumnFamilyDescriptor> column_families;\ncolumn_families.push_back(rocksdb::ColumnFamilyDescriptor(\n    rocksdb::kDefaultColumnFamilyName, rocksdb::ColumnFamilyOptions()));",
            "explanation": "Uses column families to organize different logical databases within the same RocksDB instance."
          }
        ],
        "best_practices": [
          "Use `WriteBatch` for grouped writes to improve performance.",
          "Leverage column families for data partitioning and better management.",
          "Use Bloom filters for fast point-lookups.",
          "Monitor compaction and tune it for your workload to avoid performance bottlenecks.",
          "Enable compression (e.g., Snappy, Zstd) to save storage space."
        ],
        "error_handling": [
          {
            "error": "Status::NotFound",
            "solution": "Indicates the requested key does not exist. Always check `status.ok()` before using results."
          },
          {
            "error": "Corruption errors",
            "solution": "May happen if the database files are corrupted. Run RocksDB repair tools or restore from backup."
          },
          {
            "error": "Performance degradation",
            "solution": "Adjust compaction strategy, memory tables, and background thread settings to match workload."
          }
        ]
      },
      "references": {
        "official_docs": "https://rocksdb.org/docs/getting-started.html",
        "github": "https://github.com/facebook/rocksdb"
      }
    },
    {
      "id": "lmdb",
      "name": "LMDB",
      "category": "Database",
      "description": "LMDB (Lightning Memory-Mapped Database) is a high-performance, memory-mapped key-value store developed by the OpenLDAP project. It is compact, transactional, and highly efficient, designed for read-heavy workloads with low latency.",
      "story": "LMDB was created by Howard Chu of the OpenLDAP project to provide a lightweight, transactional database for LDAP storage. Unlike traditional databases, LMDB uses memory-mapped files, allowing it to achieve excellent performance with minimal overhead. It has since been adopted widely in blockchain systems, distributed storage, and embedded applications.",
      "installation": {
        "linux": "sudo apt install liblmdb-dev",
        "mac": "brew install lmdb",
        "windows": "vcpkg install lmdb or build from source"
      },
      "usage": {
        "overview": "LMDB provides a transactional key-value store API, supporting ACID properties, multiple named databases, and concurrent readers. It is optimized for read-heavy workloads with very fast lookup performance.",
        "basic_examples": [
          {
            "title": "Creating and writing to a database",
            "code": "#include <lmdb.h>\n#include <iostream>\n\nint main() {\n    MDB_env* env;\n    MDB_dbi dbi;\n    MDB_val key, data;\n    MDB_txn* txn;\n    MDB_cursor* cursor;\n\n    // Create environment\n    mdb_env_create(&env);\n    mdb_env_set_maxdbs(env, 1);\n    mdb_env_open(env, \"./testdb\", 0, 0664);\n\n    // Start transaction\n    mdb_txn_begin(env, NULL, 0, &txn);\n    mdb_open(txn, NULL, 0, &dbi);\n\n    key.mv_size = 5; key.mv_data = (void*)\"hello\";\n    data.mv_size = 5; data.mv_data = (void*)\"world\";\n\n    mdb_put(txn, dbi, &key, &data, 0);\n    mdb_txn_commit(txn);\n\n    mdb_close(env, dbi);\n    mdb_env_close(env);\n    return 0;\n}",
            "explanation": "Creates an LMDB environment, inserts a key-value pair (`hello -> world`), and commits the transaction."
          }
        ],
        "advanced_examples": [
          {
            "title": "Reading values",
            "code": "mdb_txn_begin(env, NULL, MDB_RDONLY, &txn);\nmdb_cursor_open(txn, dbi, &cursor);\nwhile (mdb_cursor_get(cursor, &key, &data, MDB_NEXT) == 0) {\n    std::cout << (char*)key.mv_data << \" => \" << (char*)data.mv_data << std::endl;\n}\nmdb_cursor_close(cursor);\nmdb_txn_abort(txn);",
            "explanation": "Iterates over all key-value pairs in the LMDB database."
          },
          {
            "title": "Using multiple databases",
            "code": "mdb_open(txn, \"users\", MDB_CREATE, &dbi);",
            "explanation": "Opens a named sub-database inside the LMDB environment."
          },
          {
            "title": "Transactions",
            "code": "mdb_txn_begin(env, NULL, 0, &txn);\n// Perform operations\nmdb_txn_commit(txn);",
            "explanation": "Ensures ACID compliance by explicitly wrapping operations in transactions."
          },
          {
            "title": "Concurrent readers",
            "code": "mdb_txn_begin(env, NULL, MDB_RDONLY, &txn);",
            "explanation": "LMDB allows multiple concurrent read-only transactions without blocking writers."
          }
        ],
        "best_practices": [
          "Use LMDB for workloads with frequent reads and fewer writes.",
          "Avoid long-running read transactions as they may block database growth.",
          "Store small to medium-sized values; LMDB is not optimized for huge blobs.",
          "Use named databases when organizing multiple datasets in the same environment.",
          "Carefully size the LMDB map to avoid resizing overhead."
        ],
        "error_handling": [
          {
            "error": "MDB_MAP_FULL",
            "solution": "Occurs when the database map size is exceeded. Increase map size with `mdb_env_set_mapsize`."
          },
          {
            "error": "MDB_BAD_TXN",
            "solution": "Happens when using a transaction after it has been committed or aborted."
          },
          {
            "error": "MDB_CORRUPTED",
            "solution": "Indicates possible data corruption. Restore from backup if repair is not possible."
          }
        ]
      },
      "references": {
        "official_docs": "http://www.lmdb.tech/doc/",
        "github": "https://github.com/LMDB/lmdb"
      }
    },
    {
      "id": "capnproto",
      "name": "Cap’n Proto",
      "category": "Serialization/Networking",
      "description": "Cap’n Proto is a fast data interchange format and RPC system. It provides schema-based serialization similar to Protocol Buffers, but with zero-copy design, enabling extremely fast message passing and storage.",
      "story": "Cap’n Proto was created by Kenton Varda, the original author of Google’s Protocol Buffers, to address performance bottlenecks in serialization. Unlike Protobuf, which requires encoding/decoding, Cap’n Proto messages are in-memory representations that can be directly written to disk or sent over the network. It is widely used in distributed systems and applications requiring low-latency communication.",
      "installation": {
        "linux": "sudo apt install capnproto libcapnp-dev",
        "mac": "brew install capnp",
        "windows": "vcpkg install capnproto or build from source with CMake"
      },
      "usage": {
        "overview": "Cap’n Proto provides a schema definition language (`.capnp` files) that describes structured data. It generates C++ code for serialization, deserialization, and RPC stubs. Its zero-copy design allows messages to be sent/received without heavy CPU overhead.",
        "basic_examples": [
          {
            "title": "Defining a schema",
            "code": "@0xbf5147cbbecf40a7;\nstruct Person {\n  id @0 :UInt64;\n  name @1 :Text;\n  email @2 :Text;\n}",
            "explanation": "Defines a simple schema for a `Person` object in a `.capnp` file."
          },
          {
            "title": "Serializing and writing data",
            "code": "#include <capnp/message.h>\n#include <capnp/serialize.h>\n#include \"person.capnp.h\"\n\nint main() {\n    ::capnp::MallocMessageBuilder message;\n    Person::Builder person = message.initRoot<Person>();\n    person.setId(123);\n    person.setName(\"Alice\");\n    person.setEmail(\"alice@example.com\");\n\n    writeMessageToFd(1, message); // Write to stdout\n    return 0;\n}",
            "explanation": "Creates a `Person` object and serializes it using Cap’n Proto."
          }
        ],
        "advanced_examples": [
          {
            "title": "Reading and deserializing data",
            "code": "::capnp::StreamFdMessageReader reader(0); // Read from stdin\nPerson::Reader person = reader.getRoot<Person>();\nstd::cout << person.getName().cStr() << std::endl;",
            "explanation": "Reads and deserializes a Cap’n Proto message from input."
          },
          {
            "title": "Using lists",
            "code": "auto friends = person.initFriends(2);\nfriends[0].setName(\"Bob\");\nfriends[1].setName(\"Charlie\");",
            "explanation": "Cap’n Proto supports strongly-typed lists of structs and primitives."
          },
          {
            "title": "Remote Procedure Calls (RPC)",
            "code": "// Cap’n Proto provides async RPC support.\n// Example: defining an interface in .capnp:\ninterface Calculator {\n  add @0 (a :Int32, b :Int32) -> (result :Int32);\n}",
            "explanation": "Cap’n Proto includes a built-in RPC system with async method calls."
          }
        ],
        "best_practices": [
          "Use Cap’n Proto when low-latency, high-throughput serialization is required.",
          "Prefer Cap’n Proto over Protobuf when zero-copy access matters.",
          "Avoid unnecessary message copies; use memory-mapped files where possible.",
          "Keep schemas stable—Cap’n Proto supports backward and forward compatibility.",
          "For RPC, combine with secure transport (e.g., TLS) since Cap’n Proto itself doesn’t enforce encryption."
        ],
        "error_handling": [
          {
            "error": "capnp::kj::Exception: message too large",
            "solution": "Adjust message size limits when working with large data structures."
          },
          {
            "error": "Schema mismatch",
            "solution": "Ensure the `.capnp` schema matches the generated C++ headers used at runtime."
          },
          {
            "error": "Serialization failure",
            "solution": "Verify that required fields are initialized before writing the message."
          }
        ]
      },
      "references": {
        "official_docs": "https://capnproto.org/",
        "github": "https://github.com/capnproto/capnproto"
      }
    },
    {
      "id": "flatbuffers",
      "name": "FlatBuffers",
      "category": "Serialization",
      "description": "FlatBuffers is a highly efficient cross-platform serialization library developed by Google. It allows direct access to serialized data without parsing/unpacking, making it ideal for games, mobile apps, and high-performance applications.",
      "story": "FlatBuffers was created at Google by Wouter van Oortmerssen in 2014 to overcome performance limitations of Protocol Buffers in gaming and mobile environments. Unlike Protobuf, FlatBuffers does not require deserialization: data can be directly accessed from the buffer, enabling faster performance with lower memory usage. It has become widely used in game engines, real-time applications, and machine learning frameworks like TensorFlow Lite.",
      "installation": {
        "linux": "sudo apt install flatbuffers-compiler libflatbuffers-dev",
        "mac": "brew install flatbuffers",
        "windows": "vcpkg install flatbuffers"
      },
      "usage": {
        "overview": "FlatBuffers uses a schema definition file (`.fbs`) to describe structured data. The `flatc` compiler generates C++ (and other language) code, which can then be used to build and access serialized objects directly from memory.",
        "basic_examples": [
          {
            "title": "Defining a schema",
            "code": "table Monster {\n  id:int;\n  name:string;\n  hp:int;\n}\nroot_type Monster;",
            "explanation": "Defines a simple schema for a `Monster` object in a `.fbs` file."
          },
          {
            "title": "Serializing data",
            "code": "#include \"monster_generated.h\"\n#include <flatbuffers/flatbuffers.h>\n\nflatbuffers::FlatBufferBuilder builder;\nauto name = builder.CreateString(\"Orc\");\nMonsterBuilder monster(builder);\nmonster.add_id(1);\nmonster.add_name(name);\nmonster.add_hp(100);\nauto orc = monster.Finish();\nbuilder.Finish(orc);\n\nuint8_t* buf = builder.GetBufferPointer();\nsize_t size = builder.GetSize();",
            "explanation": "Builds a `Monster` object and serializes it into a FlatBuffer."
          }
        ],
        "advanced_examples": [
          {
            "title": "Accessing data without deserialization",
            "code": "auto monster = GetMonster(buf);\nstd::cout << monster->name()->str() << \" has HP: \" << monster->hp() << std::endl;",
            "explanation": "FlatBuffers allows direct access to serialized data without unpacking."
          },
          {
            "title": "Using vectors",
            "code": "auto weapons = builder.CreateVectorOfStrings({\"sword\", \"axe\", \"bow\"});",
            "explanation": "FlatBuffers supports strongly typed vectors for lists of data."
          },
          {
            "title": "JSON interoperability",
            "code": "flatc --json --monster.fbs monster.json",
            "explanation": "FlatBuffers can serialize/deserialize JSON for debugging or compatibility."
          },
          {
            "title": "Version tolerance",
            "code": "Older schemas can still read newer data as long as fields are added with defaults.",
            "explanation": "FlatBuffers supports forward and backward compatibility in schemas."
          }
        ],
        "best_practices": [
          "Use FlatBuffers for performance-critical applications like games and real-time systems.",
          "Prefer accessing fields directly from the buffer instead of copying data.",
          "Design schemas with optional fields for forward compatibility.",
          "Use vectors for large repeated data instead of nested tables.",
          "Avoid excessive nesting in schemas, as it can reduce performance."
        ],
        "error_handling": [
          {
            "error": "Buffer too small / corrupted",
            "solution": "Always validate buffers with `Verifier` before accessing data."
          },
          {
            "error": "Schema mismatch",
            "solution": "Ensure `.fbs` schema used at runtime matches the generated headers."
          },
          {
            "error": "Alignment errors",
            "solution": "Ensure buffers are properly aligned when mapped from external sources."
          }
        ]
      },
      "references": {
        "official_docs": "https://google.github.io/flatbuffers/",
        "github": "https://github.com/google/flatbuffers"
      }
    },
    {
      "id": "zeromq",
      "name": "ZeroMQ",
      "category": "Networking",
      "description": "ZeroMQ is a high-performance asynchronous messaging library for building distributed and concurrent applications. It provides sockets that carry atomic messages across processes, machines, or threads with patterns like pub-sub, request-reply, and pipeline.",
      "story": "ZeroMQ (also known as ØMQ) was created in 2007 by iMatix Corporation to provide a lightweight messaging layer that is faster and more flexible than traditional message brokers like AMQP or JMS. Unlike typical brokers, ZeroMQ is brokerless—applications communicate directly via sockets while still supporting rich messaging patterns. It has become popular in finance, IoT, distributed systems, and high-performance computing.",
      "installation": {
        "linux": "sudo apt install libzmq3-dev",
        "mac": "brew install zeromq",
        "windows": "vcpkg install zeromq"
      },
      "usage": {
        "overview": "ZeroMQ provides socket types (`REQ`, `REP`, `PUB`, `SUB`, `PUSH`, `PULL`) that can be connected in messaging topologies. It supports asynchronous, non-blocking communication, high throughput, and minimal latency.",
        "basic_examples": [
          {
            "title": "Hello World server (reply)",
            "code": "#include <zmq.hpp>\n#include <string>\n#include <iostream>\n\nint main() {\n    zmq::context_t context(1);\n    zmq::socket_t socket(context, ZMQ_REP);\n    socket.bind(\"tcp://*:5555\");\n\n    while (true) {\n        zmq::message_t request;\n        socket.recv(request);\n        std::cout << \"Received: \" << request.to_string() << std::endl;\n\n        zmq::message_t reply(\"World\", 5);\n        socket.send(reply, zmq::send_flags::none);\n    }\n    return 0;\n}",
            "explanation": "A simple ZeroMQ server using the request-reply pattern."
          },
          {
            "title": "Hello World client (request)",
            "code": "zmq::context_t context(1);\nzmq::socket_t socket(context, ZMQ_REQ);\nsocket.connect(\"tcp://localhost:5555\");\n\nzmq::message_t request(\"Hello\", 5);\nsocket.send(request, zmq::send_flags::none);\n\nzmq::message_t reply;\nsocket.recv(reply);\nstd::cout << \"Received reply: \" << reply.to_string() << std::endl;",
            "explanation": "A simple client sending requests and receiving replies."
          }
        ],
        "advanced_examples": [
          {
            "title": "Publish-Subscribe",
            "code": "// Publisher\nzmq::socket_t pub(context, ZMQ_PUB);\npub.bind(\"tcp://*:5556\");\nzmq::message_t msg(\"Update 1\", 8);\npub.send(msg, zmq::send_flags::none);\n\n// Subscriber\nzmq::socket_t sub(context, ZMQ_SUB);\nsub.connect(\"tcp://localhost:5556\");\nsub.set(zmq::sockopt::subscribe, \"\");",
            "explanation": "Implements a pub-sub model where one publisher sends updates to many subscribers."
          },
          {
            "title": "Pipeline (Push-Pull)",
            "code": "zmq::socket_t push(context, ZMQ_PUSH);\npush.bind(\"tcp://*:5557\");\nzmq::socket_t pull(context, ZMQ_PULL);\npull.connect(\"tcp://localhost:5557\");",
            "explanation": "Implements a task distribution model where tasks are pushed by producers and pulled by workers."
          },
          {
            "title": "Non-blocking receive",
            "code": "zmq::message_t msg;\nbool received = socket.recv(msg, zmq::recv_flags::dontwait);\nif (received) {\n    std::cout << \"Got message: \" << msg.to_string() << std::endl;\n}",
            "explanation": "Demonstrates asynchronous message receiving without blocking."
          },
          {
            "title": "Polling multiple sockets",
            "code": "zmq::pollitem_t items[] = {{socket1, 0, ZMQ_POLLIN, 0}, {socket2, 0, ZMQ_POLLIN, 0}};\nzmq::poll(items, 2, 1000);",
            "explanation": "Polls multiple sockets simultaneously with a timeout."
          }
        ],
        "best_practices": [
          "Choose the right messaging pattern (`REQ-REP`, `PUB-SUB`, `PUSH-PULL`) for your use case.",
          "Use non-blocking sockets or polling to avoid deadlocks.",
          "Always close sockets and terminate the context to free resources.",
          "Handle network errors gracefully; ZeroMQ does not guarantee message delivery by default.",
          "For secure messaging, combine with encryption frameworks like CurveZMQ."
        ],
        "error_handling": [
          {
            "error": "zmq::error_t: Connection refused",
            "solution": "Ensure the server socket is bound and listening before connecting clients."
          },
          {
            "error": "zmq::error_t: Operation would block",
            "solution": "Occurs with non-blocking sockets. Check readiness with polling before sending/receiving."
          },
          {
            "error": "Dropped messages in PUB-SUB",
            "solution": "Subscribers only receive messages after they have subscribed. Consider buffering or queueing if needed."
          }
        ]
      },
      "references": {
        "official_docs": "https://zeromq.org/",
        "github": "https://github.com/zeromq/libzmq"
      }
    },
    {
      "id": "grpc",
      "name": "gRPC",
      "category": "Networking",
      "description": "gRPC is a high-performance, open-source universal RPC framework developed by Google. It uses HTTP/2 for transport, Protocol Buffers for serialization, and supports features like authentication, load balancing, and bidirectional streaming.",
      "story": "gRPC was introduced by Google in 2015 to standardize communication in microservices and distributed systems. It builds upon Protocol Buffers for schema definition and leverages HTTP/2 for efficient transport. Today, gRPC is widely adopted in cloud-native applications, Kubernetes, and service mesh environments as a modern alternative to REST.",
      "installation": {
        "linux": "sudo apt install protobuf-compiler libgrpc++-dev",
        "mac": "brew install grpc",
        "windows": "vcpkg install grpc protobuf"
      },
      "usage": {
        "overview": "gRPC uses `.proto` files to define service contracts and message schemas. The `protoc` compiler generates C++ stubs, which can be used to implement servers and clients. gRPC supports unary calls, server streaming, client streaming, and bidirectional streaming.",
        "basic_examples": [
          {
            "title": "Defining a service",
            "code": "syntax = \"proto3\";\n\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply);\n}\n\nmessage HelloRequest {\n  string name = 1;\n}\n\nmessage HelloReply {\n  string message = 1;\n}",
            "explanation": "Defines a simple gRPC service in Protocol Buffers format."
          },
          {
            "title": "Implementing a server",
            "code": "#include \"helloworld.grpc.pb.h\"\n#include <grpcpp/grpcpp.h>\n\nclass GreeterServiceImpl final : public Greeter::Service {\n  grpc::Status SayHello(grpc::ServerContext* context, const HelloRequest* request, HelloReply* reply) override {\n    reply->set_message(\"Hello \" + request->name());\n    return grpc::Status::OK;\n  }\n};",
            "explanation": "Implements the `SayHello` RPC method on the server side."
          },
          {
            "title": "Starting the server",
            "code": "int main() {\n  GreeterServiceImpl service;\n  grpc::ServerBuilder builder;\n  builder.AddListeningPort(\"0.0.0.0:50051\", grpc::InsecureServerCredentials());\n  builder.RegisterService(&service);\n  std::unique_ptr<grpc::Server> server(builder.BuildAndStart());\n  server->Wait();\n}",
            "explanation": "Starts a gRPC server on port 50051."
          },
          {
            "title": "Calling from a client",
            "code": "auto channel = grpc::CreateChannel(\"localhost:50051\", grpc::InsecureChannelCredentials());\nstd::unique_ptr<Greeter::Stub> stub = Greeter::NewStub(channel);\nHelloRequest request;\nrequest.set_name(\"World\");\nHelloReply reply;\ngr::ClientContext context;\n\ngrpc::Status status = stub->SayHello(&context, request, &reply);\nif (status.ok()) {\n  std::cout << reply.message() << std::endl;\n}",
            "explanation": "Implements a client that calls the `SayHello` RPC method."
          }
        ],
        "advanced_examples": [
          {
            "title": "Server-side streaming",
            "code": "rpc ListFeatures(Rectangle) returns (stream Feature);",
            "explanation": "gRPC supports returning streams of messages from server to client."
          },
          {
            "title": "Bidirectional streaming",
            "code": "rpc Chat(stream ChatMessage) returns (stream ChatMessage);",
            "explanation": "Both client and server can send messages independently over a stream."
          },
          {
            "title": "Using TLS encryption",
            "code": "grpc::SslServerCredentialsOptions ssl_opts;\nbuilder.AddListeningPort(\"0.0.0.0:50051\", grpc::SslServerCredentials(ssl_opts));",
            "explanation": "Enables secure gRPC communication over TLS."
          },
          {
            "title": "Deadlines and timeouts",
            "code": "context.set_deadline(std::chrono::system_clock::now() + std::chrono::seconds(5));",
            "explanation": "Specifies a timeout for an RPC call."
          }
        ],
        "best_practices": [
          "Always define clear and stable `.proto` contracts for services.",
          "Use TLS for secure communication in production environments.",
          "Leverage streaming for large datasets or long-lived connections.",
          "Set deadlines to avoid hanging RPCs.",
          "Use interceptors or middleware for logging and monitoring."
        ],
        "error_handling": [
          {
            "error": "UNAVAILABLE: failed to connect to all addresses",
            "solution": "Ensure the server is running and reachable at the specified address/port."
          },
          {
            "error": "DEADLINE_EXCEEDED",
            "solution": "The client timeout expired. Increase the deadline or optimize server response time."
          },
          {
            "error": "PERMISSION_DENIED",
            "solution": "Occurs when credentials are missing or invalid. Ensure proper authentication is configured."
          }
        ]
      },
      "references": {
        "official_docs": "https://grpc.io/docs/languages/cpp/",
        "github": "https://github.com/grpc/grpc"
      }
    },
    {
      "id": "libcurl",
      "name": "libcurl",
      "category": "Networking",
      "description": "libcurl is a free and easy-to-use client-side URL transfer library that supports a wide range of protocols including HTTP, HTTPS, FTP, FTPS, SCP, SFTP, LDAP, and more. It is widely used for making network requests and file transfers in C and C++ applications.",
      "story": "libcurl was created by Daniel Stenberg in 1997 as a tool for transferring files via HTTP. Over time, it evolved into a feature-rich library supporting dozens of internet protocols. Today, libcurl is one of the most widely used networking libraries across multiple programming languages, powering tools like Git, PHP, and countless C/C++ applications.",
      "installation": {
        "linux": "sudo apt install libcurl4-openssl-dev",
        "mac": "brew install curl",
        "windows": "vcpkg install curl"
      },
      "usage": {
        "overview": "libcurl provides a powerful API for performing network requests. It supports synchronous and asynchronous operations, connection pooling, SSL/TLS, authentication, and proxy handling.",
        "basic_examples": [
          {
            "title": "Simple HTTP GET request",
            "code": "#include <curl/curl.h>\n#include <iostream>\n\nsize_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    ((std::string*)userp)->append((char*)contents, size * nmemb);\n    return size * nmemb;\n}\n\nint main() {\n    CURL* curl;\n    CURLcode res;\n    std::string readBuffer;\n\n    curl = curl_easy_init();\n    if (curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com\");\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);\n        res = curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n    }\n    std::cout << readBuffer << std::endl;\n    return 0;\n}",
            "explanation": "Performs an HTTP GET request to fetch a webpage and print its contents."
          },
          {
            "title": "HTTP POST request",
            "code": "curl_easy_setopt(curl, CURLOPT_URL, \"https://httpbin.org/post\");\ncurl_easy_setopt(curl, CURLOPT_POSTFIELDS, \"field1=value1&field2=value2\");",
            "explanation": "Sends a POST request with form data."
          }
        ],
        "advanced_examples": [
          {
            "title": "Handling HTTPS requests",
            "code": "curl_easy_setopt(curl, CURLOPT_URL, \"https://secure.example.com\");\ncurl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);\ncurl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);",
            "explanation": "Configures libcurl to verify SSL certificates when making HTTPS requests."
          },
          {
            "title": "Setting custom headers",
            "code": "struct curl_slist* headers = NULL;\nheaders = curl_slist_append(headers, \"Content-Type: application/json\");\ncurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);",
            "explanation": "Adds custom HTTP headers to a request, useful for APIs."
          },
          {
            "title": "File download",
            "code": "FILE* fp = fopen(\"file.zip\", \"wb\");\ncurl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/file.zip\");\ncurl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\ncurl_easy_perform(curl);\nfclose(fp);",
            "explanation": "Downloads a file directly to disk."
          },
          {
            "title": "Asynchronous multi-request",
            "code": "CURLM* multi_handle = curl_multi_init();\ncurl_multi_add_handle(multi_handle, curl1);\ncurl_multi_add_handle(multi_handle, curl2);\n// Run event loop for multiple concurrent transfers",
            "explanation": "Uses the `multi` interface for handling multiple requests concurrently."
          }
        ],
        "best_practices": [
          "Always call `curl_global_init()` before using libcurl in multi-threaded apps.",
          "Use the easy interface for simple requests, and the multi interface for concurrency.",
          "Always clean up handles with `curl_easy_cleanup()` and `curl_global_cleanup()`.",
          "Enable SSL certificate verification in production for security.",
          "Reuse connections for performance by enabling connection pooling."
        ],
        "error_handling": [
          {
            "error": "CURLE_COULDNT_RESOLVE_HOST",
            "solution": "Check DNS resolution and ensure the hostname is valid."
          },
          {
            "error": "CURLE_SSL_CONNECT_ERROR",
            "solution": "Verify SSL certificates and ensure proper TLS configuration."
          },
          {
            "error": "CURLE_OPERATION_TIMEDOUT",
            "solution": "Increase timeout settings using `CURLOPT_TIMEOUT` or optimize network conditions."
          }
        ]
      },
      "references": {
        "official_docs": "https://curl.se/libcurl/c/",
        "github": "https://github.com/curl/curl"
      }
    },
    {
      "id": "uwebsockets",
      "name": "uWebSockets",
      "category": "Networking",
      "description": "uWebSockets is a highly efficient C++ WebSocket and HTTP library designed for scalability and minimal resource usage. It supports millions of concurrent connections and powers some of the largest real-time applications, including trading platforms and messaging systems.",
      "story": "uWebSockets was created by Alexander Aaltonen (known as 'alexhultman') to address the inefficiencies of existing WebSocket libraries. Written in C++, it leverages event loops, modern epoll/kqueue, and optimized memory handling to achieve industry-leading performance. Today, it is used in large-scale production systems where latency and throughput are critical.",
      "installation": {
        "linux": "git clone https://github.com/uNetworking/uWebSockets.git && cd uWebSockets && make",
        "mac": "brew install uwebsockets",
        "windows": "vcpkg install uwebsockets"
      },
      "usage": {
        "overview": "uWebSockets provides an event-driven API for handling WebSocket and HTTP connections. It allows developers to build high-performance servers that can handle millions of clients concurrently.",
        "basic_examples": [
          {
            "title": "Hello World WebSocket server",
            "code": "#include <uwebsockets/App.h>\n\nint main() {\n    uWS::App().ws<false>(\"/\", {\n        .open = [](auto* ws) {\n            std::cout << \"A client connected\" << std::endl;\n        },\n        .message = [](auto* ws, std::string_view message, uWS::OpCode opCode) {\n            ws->send(\"Hello, \" + std::string(message), opCode);\n        }\n    }).listen(9001, [](auto* token) {\n        if (token) std::cout << \"Listening on port 9001\" << std::endl;\n    }).run();\n}\n",
            "explanation": "A minimal WebSocket server that echoes back messages with a greeting."
          },
          {
            "title": "Basic HTTP server",
            "code": "uWS::App().get(\"/hello\", [](auto* res, auto* req) {\n    res->end(\"Hello, HTTP!\");\n}).listen(8080, [](auto* token) {\n    if (token) std::cout << \"Listening on port 8080\" << std::endl;\n}).run();",
            "explanation": "Implements a simple HTTP endpoint responding with 'Hello, HTTP!'."
          }
        ],
        "advanced_examples": [
          {
            "title": "Broadcast to all clients",
            "code": "auto wsGroup = uWS::App().ws<false>(\"/chat\", {\n    .message = [](auto* ws, std::string_view msg, uWS::OpCode opCode) {\n        ws->publish(\"chat\", msg, opCode);\n    }\n});",
            "explanation": "Implements a chat room by broadcasting messages to all clients."
          },
          {
            "title": "Handling large payloads",
            "code": "uWS::App().ws<false>(\"/\", {\n    .message = [](auto* ws, std::string_view msg, uWS::OpCode) {\n        if (msg.size() > 1024) {\n            ws->send(\"Payload too large\");\n        }\n    }\n});",
            "explanation": "Demonstrates handling and validating large incoming messages."
          },
          {
            "title": "SSL/TLS support",
            "code": "uWS::App().ws<false>(\"/\", {\n    .open = [](auto* ws) { std::cout << \"Secure connection!\"; }\n}).listen(9002, [](auto* token) { });",
            "explanation": "Supports secure WebSocket (wss://) connections with TLS certificates."
          },
          {
            "title": "Per-message compression",
            "code": "uWS::App().ws<false>(\"/\", {\n    .compression = uWS::SHARED_COMPRESSOR\n});",
            "explanation": "Enables per-message WebSocket compression to save bandwidth."
          }
        ],
        "best_practices": [
          "Use the correct event loop (epoll/kqueue) for your platform for best performance.",
          "Enable per-message compression for bandwidth efficiency in large-scale apps.",
          "Validate incoming data to prevent abuse (e.g., large payloads, invalid frames).",
          "Leverage channels (`publish`/`subscribe`) for efficient broadcasting.",
          "Use TLS in production to secure WebSocket and HTTP traffic."
        ],
        "error_handling": [
          {
            "error": "Connection dropped unexpectedly",
            "solution": "Implement proper `close` handlers to gracefully handle disconnections."
          },
          {
            "error": "SSL handshake failure",
            "solution": "Verify TLS certificate and key configuration for secure connections."
          },
          {
            "error": "High memory usage",
            "solution": "Use shared compressors and configure max payload sizes to avoid memory spikes."
          }
        ]
      },
      "references": {
        "official_docs": "https://unetworking.github.io/uWebSockets.js/generated/index.html",
        "github": "https://github.com/uNetworking/uWebSockets"
      }
    },
    {
      "id": "onetbb",
      "name": "Intel oneTBB",
      "category": "Concurrency/Parallelism",
      "description": "Intel oneTBB (Threading Building Blocks) is a C++ template library that simplifies parallel programming by providing high-level abstractions for tasks, parallel loops, pipelines, and concurrent data structures. It enables developers to harness multicore processors efficiently without directly managing threads.",
      "story": "Threading Building Blocks (TBB) was originally developed by Intel in 2006 to address the growing need for parallelism as CPUs moved to multi-core architectures. In 2021, Intel contributed TBB to the Linux Foundation under the new name oneTBB, making it open and community-driven. Today, oneTBB is widely used in HPC, finance, gaming, scientific computing, and data analytics.",
      "installation": {
        "linux": "sudo apt install libtbb-dev",
        "mac": "brew install tbb",
        "windows": "vcpkg install tbb"
      },
      "usage": {
        "overview": "oneTBB provides parallel loops, parallel algorithms, concurrent containers, and task schedulers. It abstracts away thread creation and synchronization, making it easier to write scalable parallel code.",
        "basic_examples": [
          {
            "title": "Parallel for loop",
            "code": "#include <tbb/parallel_for.h>\n#include <iostream>\n\nint main() {\n    tbb::parallel_for(0, 10, [](int i) {\n        std::cout << \"Processing index: \" << i << std::endl;\n    });\n    return 0;\n}",
            "explanation": "Runs a parallel loop from 0 to 9 across available CPU cores."
          },
          {
            "title": "Parallel reduce",
            "code": "#include <tbb/parallel_reduce.h>\n#include <tbb/blocked_range.h>\n#include <iostream>\n\nint main() {\n    int sum = tbb::parallel_reduce(\n        tbb::blocked_range<int>(0, 100), 0,\n        [](const tbb::blocked_range<int>& r, int init) {\n            for (int i = r.begin(); i < r.end(); ++i)\n                init += i;\n            return init;\n        },\n        [](int x, int y) { return x + y; }\n    );\n    std::cout << \"Sum: \" << sum << std::endl;\n}",
            "explanation": "Performs a parallel sum reduction of numbers from 0 to 99."
          }
        ],
        "advanced_examples": [
          {
            "title": "Parallel pipeline",
            "code": "#include <tbb/pipeline.h>\n#include <iostream>\n\nint main() {\n    tbb::parallel_pipeline(\n        4,\n        tbb::make_filter<void, int>(tbb::filter_mode::serial_in_order, [](tbb::flow_control& fc) -> int {\n            static int count = 0;\n            if (count < 10) return count++;\n            fc.stop();\n            return 0;\n        }) &\n        tbb::make_filter<int, void>(tbb::filter_mode::parallel, [](int x) {\n            std::cout << \"Processing item: \" << x << std::endl;\n        })\n    );\n}",
            "explanation": "Implements a parallel pipeline with a producer and consumer stage."
          },
          {
            "title": "Concurrent hash map",
            "code": "#include <tbb/concurrent_hash_map.h>\n#include <iostream>\n\nint main() {\n    tbb::concurrent_hash_map<int, int> cmap;\n    cmap.insert({1, 100});\n    cmap.insert({2, 200});\n    tbb::concurrent_hash_map<int, int>::const_accessor a;\n    if (cmap.find(a, 1)) std::cout << \"Key 1 value: \" << a->second << std::endl;\n}",
            "explanation": "Demonstrates thread-safe access to a concurrent hash map."
          },
          {
            "title": "Task arenas",
            "code": "#include <tbb/task_arena.h>\n\nint main() {\n    tbb::task_arena arena(2); // restrict to 2 threads\n    arena.execute([] {\n        tbb::parallel_for(0, 5, [](int i) {\n            std::cout << \"Running in restricted arena: \" << i << std::endl;\n        });\n    });\n}",
            "explanation": "Executes tasks inside a custom thread arena."
          }
        ],
        "best_practices": [
          "Prefer TBB algorithms (`parallel_for`, `parallel_reduce`) over manual thread management.",
          "Use concurrent containers (`concurrent_vector`, `concurrent_hash_map`) to avoid data races.",
          "Avoid oversubscribing threads by letting TBB manage the thread pool.",
          "Combine with STL algorithms and lambda expressions for clean, modern C++ parallelism.",
          "Use task arenas to isolate workloads with different concurrency needs."
        ],
        "error_handling": [
          {
            "error": "Performance degradation due to false sharing",
            "solution": "Ensure data structures are properly padded/aligned to avoid cache contention."
          },
          {
            "error": "Deadlocks in pipelines",
            "solution": "Check that filters properly forward or terminate flow control."
          },
          {
            "error": "Oversubscription of CPU cores",
            "solution": "Avoid mixing TBB with raw threads; rely on TBB's task scheduler."
          }
        ]
      },
      "references": {
        "official_docs": "https://oneapi-src.github.io/oneTBB/",
        "github": "https://github.com/oneapi-src/oneTBB"
      }
    },
    {
      "id": "openmp",
      "name": "OpenMP",
      "category": "Concurrency/Parallelism",
      "description": "OpenMP (Open Multi-Processing) is an API that supports multi-platform shared-memory multiprocessing programming in C, C++, and Fortran. It provides a set of compiler directives, runtime library routines, and environment variables for parallelizing code easily on multi-core CPUs.",
      "story": "OpenMP was introduced in 1997 as a standard API for parallel programming on shared-memory architectures. It is supported by major compilers like GCC, Clang, Intel, and MSVC. OpenMP has become a key tool in scientific computing, engineering simulations, and data-intensive applications where developers need to scale across multiple cores without manually managing threads.",
      "installation": {
        "linux": "GCC/Clang support OpenMP with the flag: -fopenmp",
        "mac": "brew install libomp && compile with -Xpreprocessor -fopenmp -lomp",
        "windows": "MSVC supports OpenMP with /openmp flag"
      },
      "usage": {
        "overview": "OpenMP provides compiler pragmas (directives) for parallel loops, sections, tasks, synchronization, and reductions. It enables shared-memory parallelism with minimal changes to code.",
        "basic_examples": [
          {
            "title": "Parallel for loop",
            "code": "#include <omp.h>\n#include <iostream>\n\nint main() {\n    #pragma omp parallel for\n    for (int i = 0; i < 8; i++) {\n        std::cout << \"Thread \" << omp_get_thread_num() << \" processing index: \" << i << std::endl;\n    }\n    return 0;\n}",
            "explanation": "Distributes loop iterations across available threads."
          },
          {
            "title": "Reduction (sum)",
            "code": "#include <omp.h>\n#include <iostream>\n\nint main() {\n    int sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 1; i <= 100; i++) sum += i;\n    std::cout << \"Sum: \" << sum << std::endl;\n}",
            "explanation": "Performs a parallel reduction to compute the sum of numbers."
          }
        ],
        "advanced_examples": [
          {
            "title": "Parallel sections",
            "code": "#pragma omp parallel sections\n{\n    #pragma omp section\n    { task1(); }\n\n    #pragma omp section\n    { task2(); }\n}",
            "explanation": "Runs independent tasks concurrently in different sections."
          },
          {
            "title": "Tasks",
            "code": "#pragma omp parallel\n{\n    #pragma omp single\n    {\n        #pragma omp task\n        taskA();\n\n        #pragma omp task\n        taskB();\n    }\n}",
            "explanation": "Creates explicit parallel tasks for fine-grained concurrency."
          },
          {
            "title": "Critical section",
            "code": "#pragma omp parallel for\nfor (int i = 0; i < 100; i++) {\n    #pragma omp critical\n    {\n        std::cout << \"Index: \" << i << std::endl;\n    }\n}",
            "explanation": "Ensures that only one thread executes the critical section at a time."
          },
          {
            "title": "Barrier synchronization",
            "code": "#pragma omp parallel\n{\n    initialize();\n    #pragma omp barrier\n    compute();\n}",
            "explanation": "Synchronizes all threads before continuing."
          }
        ],
        "best_practices": [
          "Start with coarse-grained parallelism (e.g., loop parallelization) before fine-grained tasks.",
          "Use `reduction` for safe accumulation of results across threads.",
          "Avoid false sharing by aligning shared data on cache line boundaries.",
          "Use `schedule(dynamic)` for irregular workloads to balance load.",
          "Profile performance; more threads do not always mean faster execution."
        ],
        "error_handling": [
          {
            "error": "Unexpected results due to race conditions",
            "solution": "Use `critical`, `atomic`, or reduction clauses to protect shared data."
          },
          {
            "error": "Program slower with OpenMP enabled",
            "solution": "Check if workload is too small; overhead may outweigh benefits."
          },
          {
            "error": "Excessive memory usage",
            "solution": "Limit private copies of large arrays; use `shared` where appropriate."
          }
        ]
      },
      "references": {
        "official_docs": "https://www.openmp.org/specifications/",
        "tutorials": "https://hpc-tutorials.llnl.gov/openmp/"
      }
    },
    {
      "id": "hpx",
      "name": "HPX",
      "category": "Concurrency/Parallelism",
      "description": "HPX (High Performance ParalleX) is a C++ runtime system for parallel and distributed applications. It provides a standards-conforming API for asynchronous task-based programming, scalability across many cores, and distributed computing with an emphasis on performance portability.",
      "story": "HPX was developed as part of the ParalleX execution model, a research initiative to overcome the limitations of traditional parallel programming approaches. It is designed as a modern C++ runtime that unifies local and distributed computing under a single asynchronous API. HPX has gained adoption in scientific computing, high-performance computing (HPC), and research environments due to its ability to scale efficiently on thousands of nodes.",
      "installation": {
        "linux": "sudo apt install libhpx-dev",
        "mac": "brew install hpx",
        "windows": "vcpkg install hpx"
      },
      "usage": {
        "overview": "HPX offers C++ standard-like parallel algorithms (`for_each`, `reduce`, etc.), futures, channels, distributed objects, and executors. It integrates deeply with modern C++ (C++11 and beyond) and emphasizes asynchronous execution using futures and continuations.",
        "basic_examples": [
          {
            "title": "Hello World with HPX",
            "code": "#include <hpx/hpx_main.hpp>\n#include <hpx/include/iostreams.hpp>\n\nint main() {\n    hpx::cout << \"Hello, HPX!\" << hpx::endl;\n    return 0;\n}",
            "explanation": "A minimal HPX program that runs with the HPX runtime system initialized."
          },
          {
            "title": "Parallel for loop",
            "code": "#include <hpx/hpx_main.hpp>\n#include <hpx/include/parallel_for_each.hpp>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> data = {1, 2, 3, 4, 5};\n    hpx::for_each(hpx::execution::par, data.begin(), data.end(), [](int& n) {\n        n *= 2;\n    });\n    for (int n : data) std::cout << n << \" \";\n    return 0;\n}",
            "explanation": "Doubles all elements in a vector in parallel using HPX's parallel algorithm."
          }
        ],
        "advanced_examples": [
          {
            "title": "Asynchronous tasks with futures",
            "code": "#include <hpx/hpx_main.hpp>\n#include <hpx/include/lcos.hpp>\n#include <iostream>\n\nint main() {\n    auto f = hpx::async([]() { return 42; });\n    std::cout << \"The answer is \" << f.get() << std::endl;\n}",
            "explanation": "Uses `hpx::async` to launch an asynchronous task returning a future."
          },
          {
            "title": "Continuations with then()",
            "code": "auto f = hpx::async([] { return 10; });\nauto g = f.then([](hpx::future<int> f) {\n    return f.get() * 2;\n});\nstd::cout << g.get() << std::endl;",
            "explanation": "Chains tasks together with continuations using `then()`."
          },
          {
            "title": "Distributed computing",
            "code": "#include <hpx/include/components.hpp>\n// Example: distributed object can be registered and called across nodes.",
            "explanation": "HPX allows distributing work across multiple compute nodes transparently."
          },
          {
            "title": "Channels (message passing)",
            "code": "#include <hpx/include/lcos.hpp>\n\nhpx::lcos::channel<int> ch;\nch.set(5);\nint val = ch.get();",
            "explanation": "Implements message passing between tasks with channels."
          }
        ],
        "best_practices": [
          "Use HPX’s standard-conforming algorithms (`hpx::for_each`, `hpx::reduce`) for seamless parallelism.",
          "Prefer asynchronous APIs with futures to maximize overlap of computation and communication.",
          "Leverage continuations (`then`) to chain dependent tasks efficiently.",
          "Use distributed objects when scaling across multiple nodes in a cluster.",
          "Integrate HPX with existing C++17/20 parallel STL for portability."
        ],
        "error_handling": [
          {
            "error": "Deadlocks when using futures",
            "solution": "Avoid blocking `get()` calls inside parallel tasks; use continuations instead."
          },
          {
            "error": "Excessive task overhead",
            "solution": "Batch small tasks into larger chunks to reduce scheduling overhead."
          },
          {
            "error": "Distributed runtime initialization failure",
            "solution": "Ensure proper MPI or networking support is enabled in HPX build configuration."
          }
        ]
      },
      "references": {
        "official_docs": "https://hpx.stellar-group.org/documentation/",
        "github": "https://github.com/STEllAR-GROUP/hpx"
      }
    },
    {
      "id": "gsl",
      "name": "Guidelines Support Library (GSL)",
      "category": "Utilities",
      "description": "The Guidelines Support Library (GSL) is a set of C++ utilities developed to help programmers follow the C++ Core Guidelines. It provides types and functions such as span, not_null, owner, and utilities for safer memory and pointer usage.",
      "story": "The GSL was originally developed by Microsoft as part of the C++ Core Guidelines project led by Bjarne Stroustrup and Herb Sutter. Its purpose is to provide concrete implementations of safety-oriented types that enforce best practices and help developers write more robust and secure C++ code.",
      "installation": {
        "vcpkg": "vcpkg install ms-gsl",
        "conan": "conan install gsl-lite",
        "cmake": "find_package(Microsoft.GSL CONFIG REQUIRED)"
      },
      "usage": {
        "overview": "GSL provides utility types such as span for safe array handling, not_null for non-null pointers, and owner annotations for ownership semantics. It integrates seamlessly with modern C++ projects.",
        "basic_examples": [
          {
            "title": "Using span",
            "code": "#include <gsl/span>\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    gsl::span<int> s(v);\n    for (auto x : s) std::cout << x << \" \";\n    return 0;\n}",
            "explanation": "A `span` provides a safe view over a contiguous sequence of elements without owning them."
          },
          {
            "title": "Using not_null",
            "code": "#include <gsl/gsl>\n#include <iostream>\n\nvoid process(gsl::not_null<int*> ptr) {\n    std::cout << *ptr << std::endl;\n}\n\nint main() {\n    int x = 42;\n    process(&x); // OK\n    // process(nullptr); // compile-time error\n}",
            "explanation": "`not_null` enforces at compile time that a pointer cannot be null."
          }
        ],
        "advanced_examples": [
          {
            "title": "Owner annotations",
            "code": "#include <gsl/gsl>\n#include <iostream>\n\nvoid free_resource(gsl::owner<int*> ptr) {\n    delete ptr;\n}\n\nint main() {\n    gsl::owner<int*> data = new int(10);\n    free_resource(data);\n}",
            "explanation": "`owner<T*>` documents ownership semantics and helps static analyzers detect leaks."
          },
          {
            "title": "Narrow casting",
            "code": "#include <gsl/gsl>\n#include <iostream>\n\nint main() {\n    int x = 300;\n    char c = gsl::narrow<char>(x); // runtime check for narrowing conversion\n    std::cout << (int)c << std::endl;\n}",
            "explanation": "`gsl::narrow` performs narrowing casts with runtime checks to prevent unsafe conversions."
          },
          {
            "title": "Ensuring contracts",
            "code": "#include <gsl/gsl_assert>\n#include <iostream>\n\nint divide(int a, int b) {\n    Expects(b != 0); // precondition\n    return a / b;\n}\n\nint main() {\n    std::cout << divide(10, 2) << std::endl;\n}",
            "explanation": "Uses `Expects` and `Ensures` macros to declare preconditions and postconditions."
          }
        ],
        "best_practices": [
          "Use `span` instead of raw pointers or array references for safe and expressive code.",
          "Mark ownership explicitly using `owner<T*>` to improve readability and analysis.",
          "Use `not_null` whenever null pointers are not valid inputs.",
          "Adopt `narrow` for safe casting between numeric types.",
          "Leverage `Expects` and `Ensures` macros to enforce contracts in critical functions."
        ],
        "error_handling": [
          {
            "error": "Invalid span access",
            "solution": "Ensure the underlying container is not destroyed while span is in use."
          },
          {
            "error": "Null pointer passed to not_null",
            "solution": "Refactor to avoid null usage or wrap with `std::optional` where applicable."
          },
          {
            "error": "Narrowing cast failed",
            "solution": "Use a wider type or validate inputs before applying `narrow`."
          }
        ]
      },
      "references": {
        "official_docs": "https://github.com/microsoft/GSL",
        "cpp_core_guidelines": "https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines"
      }
    },
    {
      "id": "entt",
      "name": "EnTT",
      "category": "Game Development / Utilities",
      "description": "EnTT is a fast and flexible C++ Entity-Component-System (ECS) library used in game development and simulation. It provides efficient memory management, entity lifecycle handling, component storage, and iteration utilities for building scalable and data-driven applications.",
      "story": "EnTT was created by Michele Caini to provide a modern, high-performance ECS framework for C++. Unlike traditional object-oriented game engines, ECS focuses on separating data (components) from behavior (systems), enabling better performance and scalability. EnTT has gained popularity in both indie and professional game development as well as simulations and modeling.",
      "installation": {
        "cmake": "find_package(EnTT CONFIG REQUIRED)",
        "vcpkg": "vcpkg install entt",
        "conan": "conan install entt"
      },
      "usage": {
        "overview": "EnTT allows developers to create entities, assign components, and iterate over them efficiently. It leverages modern C++ templates and compile-time features to minimize overhead while maximizing flexibility.",
        "basic_examples": [
          {
            "title": "Creating entities and components",
            "code": "#include <entt/entt.hpp>\n#include <iostream>\n\nstruct Position { float x, y; };\nstruct Velocity { float dx, dy; };\n\nint main() {\n    entt::registry registry;\n    auto entity = registry.create();\n    registry.emplace<Position>(entity, 0.f, 0.f);\n    registry.emplace<Velocity>(entity, 1.f, 1.f);\n    std::cout << \"Entity created with Position and Velocity.\" << std::endl;\n    return 0;\n}",
            "explanation": "Creates an entity and assigns `Position` and `Velocity` components."
          },
          {
            "title": "Iterating over components",
            "code": "registry.view<Position, Velocity>().each([](auto entity, auto& pos, auto& vel) {\n    pos.x += vel.dx;\n    pos.y += vel.dy;\n});",
            "explanation": "Iterates over all entities with both `Position` and `Velocity` components and updates positions."
          }
        ],
        "advanced_examples": [
          {
            "title": "Systems and processing",
            "code": "auto view = registry.view<Position, Velocity>();\nfor (auto entity : view) {\n    auto &pos = view.get<Position>(entity);\n    auto &vel = view.get<Velocity>(entity);\n    pos.x += vel.dx;\n    pos.y += vel.dy;\n}",
            "explanation": "Implements a basic system to update positions based on velocity."
          },
          {
            "title": "Signals and events",
            "code": "struct CollisionEvent { entt::entity a, b; };\n\nentt::dispatcher dispatcher;\ndispatcher.sink<CollisionEvent>().connect([](const CollisionEvent& e){\n    std::cout << \"Collision detected!\" << std::endl;\n});\n\ndispatcher.trigger(CollisionEvent{entity1, entity2});",
            "explanation": "Uses EnTT’s dispatcher system to handle game events like collisions."
          },
          {
            "title": "Groups for optimization",
            "code": "auto group = registry.group<Position, Velocity>();\nfor (auto entity : group) {\n    auto &[pos, vel] = group.get<Position, Velocity>(entity);\n    pos.x += vel.dx;\n    pos.y += vel.dy;\n}",
            "explanation": "Groups entities by tightly-coupled components for faster iteration."
          }
        ],
        "best_practices": [
          "Favor composition (components + systems) over inheritance for scalability.",
          "Use groups or views for performance-sensitive iteration.",
          "Keep components lightweight and focused on data only.",
          "Leverage EnTT’s signals and dispatcher for decoupled event handling.",
          "Profile your ECS usage to avoid creating too many small entities unnecessarily."
        ],
        "error_handling": [
          {
            "error": "Accessing non-existent component",
            "solution": "Check with `registry.all_of<T>(entity)` before accessing components."
          },
          {
            "error": "Performance issues with sparse components",
            "solution": "Use groups or compact storage to improve memory locality."
          },
          {
            "error": "Entity lifecycle mismanagement",
            "solution": "Always destroy unused entities with `registry.destroy(entity)`."
          }
        ]
      },
      "references": {
        "official_docs": "https://skypjack.github.io/entt/",
        "github": "https://github.com/skypjack/entt"
      }
    },
    {
      "id": "cli11",
      "name": "CLI11",
      "category": "Utilities",
      "description": "CLI11 is a C++11 header-only library for parsing command line arguments. It provides an expressive, modern C++ API for handling flags, options, subcommands, and configuration files with minimal boilerplate.",
      "story": "CLI11 was created by Henry Schreiner to modernize C++ command line parsing. It was designed to be lightweight, flexible, and integrate naturally with C++11 and newer standards. Today, it is widely used in scientific software, tools, and utilities where robust command-line interfaces are needed.",
      "installation": {
        "cmake": "find_package(CLI11 CONFIG REQUIRED)",
        "vcpkg": "vcpkg install cli11",
        "conan": "conan install cli11"
      },
      "usage": {
        "overview": "CLI11 makes it simple to define options, flags, and subcommands while handling validation, default values, and automatic help text generation.",
        "basic_examples": [
          {
            "title": "Basic flag and option",
            "code": "#include <CLI/CLI.hpp>\n#include <iostream>\n\nint main(int argc, char** argv) {\n    CLI::App app{\"My Program\"};\n\n    int count;\n    app.add_option(\"-c,--count\", count, \"Number of iterations\");\n\n    bool verbose = false;\n    app.add_flag(\"-v,--verbose\", verbose, \"Enable verbose output\");\n\n    CLI11_PARSE(app, argc, argv);\n\n    std::cout << \"Count: \" << count << \" Verbose: \" << verbose << std::endl;\n    return 0;\n}",
            "explanation": "Parses a numeric option `--count` and a boolean flag `--verbose`."
          }
        ],
        "advanced_examples": [
          {
            "title": "Subcommands",
            "code": "CLI::App app{\"Main app\"};\nauto* sub = app.add_subcommand(\"convert\", \"Convert files\");\nstd::string input;\nsub->add_option(\"input\", input, \"Input file\")->required();\n\nCLI11_PARSE(app, argc, argv);\n\nif (*sub) {\n    std::cout << \"Converting file: \" << input << std::endl;\n}",
            "explanation": "Defines a `convert` subcommand with required arguments."
          },
          {
            "title": "Default values and validation",
            "code": "int threads = 4;\napp.add_option(\"-t,--threads\", threads, \"Number of threads\")->check(CLI::PositiveNumber);\n",
            "explanation": "Provides a default value and validates that threads must be positive."
          },
          {
            "title": "Configuration file",
            "code": "std::string config;\napp.set_config(\"config.ini\", true);\napp.add_option(\"--config\", config, \"Config file\");",
            "explanation": "Supports configuration files for loading command line arguments."
          },
          {
            "title": "Enums",
            "code": "enum class Mode { fast, slow };\nMode mode;\napp.add_option(\"--mode\", mode)\n    ->transform(CLI::CheckedTransformer({{\"fast\", Mode::fast}, {\"slow\", Mode::slow}}));",
            "explanation": "Allows parsing enums with string-to-enum transformation."
          }
        ],
        "best_practices": [
          "Use descriptive names for flags and options to improve usability.",
          "Leverage validation checks to enforce correct argument values.",
          "Group related commands into subcommands for structured CLI design.",
          "Provide default values where applicable for a smoother user experience.",
          "Use `app.set_config()` to combine command-line and config file parsing."
        ],
        "error_handling": [
          {
            "error": "Unrecognized flag or option",
            "solution": "CLI11 automatically provides helpful error messages and usage text."
          },
          {
            "error": "Required option missing",
            "solution": "Mark options as `required()` only when absolutely necessary."
          },
          {
            "error": "Invalid type conversion",
            "solution": "Use `transform` or `check` validators to prevent invalid input."
          }
        ]
      },
      "references": {
        "official_docs": "https://cliutils.github.io/CLI11/",
        "github": "https://github.com/CLIUtils/CLI11"
      }
    },
    {
      "id": "loctest",
      "name": "loctest",
      "category": "Testing",
      "description": "loctest is a lightweight and minimal C++ testing framework designed to provide simple and readable unit tests. It focuses on clarity and small binary size, making it a good choice for embedded systems and projects that don’t require heavy testing infrastructure.",
      "story": "loctest was created as part of the wave of minimal C++ testing libraries that emerged alongside Catch2 and doctest. Its main goal is to reduce boilerplate while keeping tests close to the production code. Developers adopt loctest for projects where simplicity, readability, and low overhead matter most.",
      "installation": {
        "cmake": "add_subdirectory(loctest)",
        "vcpkg": "vcpkg install loctest",
        "manual": "Download loctest.hpp and include it in your project"
      },
      "usage": {
        "overview": "loctest provides macros for defining test cases and assertions. It is header-only and integrates easily into any project.",
        "basic_examples": [
          {
            "title": "Hello world test",
            "code": "#define LOCTEST_MAIN\n#include <loctest/loctest.hpp>\n\nTEST_CASE(\"Basic test\") {\n    int a = 2 + 2;\n    REQUIRE(a == 4);\n}",
            "explanation": "Defines a basic test case using `TEST_CASE` and `REQUIRE`."
          }
        ],
        "advanced_examples": [
          {
            "title": "Multiple test cases",
            "code": "TEST_CASE(\"Addition works\") {\n    REQUIRE(2 + 3 == 5);\n}\n\nTEST_CASE(\"Multiplication works\") {\n    REQUIRE(3 * 3 == 9);\n}",
            "explanation": "Multiple test cases can be defined independently."
          },
          {
            "title": "Sections within a test",
            "code": "TEST_CASE(\"Math operations\") {\n    SECTION(\"Addition\") {\n        REQUIRE(1 + 1 == 2);\n    }\n    SECTION(\"Subtraction\") {\n        REQUIRE(5 - 2 == 3);\n    }\n}",
            "explanation": "Uses sections to organize related assertions inside one test case."
          },
          {
            "title": "Custom messages",
            "code": "int x = 10;\nint y = 5;\nREQUIRE_MESSAGE(x > y, \"Expected x > y, but got x=\" << x << \", y=\" << y);",
            "explanation": "Provides descriptive failure messages when an assertion fails."
          }
        ],
        "best_practices": [
          "Use `TEST_CASE` names that clearly describe the expected behavior.",
          "Group related assertions with `SECTION` for readability.",
          "Add failure messages for complex expressions to aid debugging.",
          "Keep tests small and focused to isolate failures.",
          "Integrate loctest into CI pipelines for automated validation."
        ],
        "error_handling": [
          {
            "error": "Undefined reference to main",
            "solution": "Define `#define LOCTEST_MAIN` in exactly one source file."
          },
          {
            "error": "Test case not running",
            "solution": "Ensure the test file is compiled and linked into the test binary."
          },
          {
            "error": "False positives on floating-point comparisons",
            "solution": "Use approximate comparisons or tolerance checks for floating-point values."
          }
        ]
      },
      "references": {
        "official_docs": "https://github.com/doctest/doctest (loctest is often considered a minimal variant)",
        "github": "https://github.com/loctest/loctest"
      }
    },
    {
      "id": "trompeloeil",
      "name": "Trompeloeil",
      "category": "Testing",
      "description": "Trompeloeil is a modern C++14 mocking framework for unit testing. It provides a type-safe, expressive API for creating mocks, setting expectations, and verifying interactions between objects.",
      "story": "Trompeloeil was created by Björn Fahller to bring a clean, type-safe, and powerful mocking library to modern C++. Its name comes from the French term 'trompe-l'œil', meaning 'deceive the eye', reflecting the way mocks pretend to be real objects during testing. Today, Trompeloeil is used widely in C++ projects alongside testing frameworks like Catch2, doctest, and Google Test.",
      "installation": {
        "cmake": "find_package(Trompeloeil CONFIG REQUIRED)",
        "vcpkg": "vcpkg install trompeloeil",
        "conan": "conan install trompeloeil",
        "manual": "Download and include trompeloeil.hpp (header-only)"
      },
      "usage": {
        "overview": "Trompeloeil allows developers to create mocks of interfaces or abstract classes, define expectations on method calls, and verify those expectations at runtime.",
        "basic_examples": [
          {
            "title": "Basic mock interface",
            "code": "#include <trompeloeil.hpp>\n#include <catch2/catch_test_macros.hpp>\n\nstruct Printer {\n    virtual void print(const std::string& msg) = 0;\n    virtual ~Printer() = default;\n};\n\nstruct MockPrinter : Printer {\n    MAKE_MOCK1(print, void(const std::string&), override);\n};\n\nTEST_CASE(\"Printer prints a message\") {\n    MockPrinter printer;\n    REQUIRE_CALL(printer, print(\"Hello\"));\n    printer.print(\"Hello\");\n}",
            "explanation": "Defines a mock `Printer` and verifies that `print(\"Hello\")` was called once."
          }
        ],
        "advanced_examples": [
          {
            "title": "Multiple expectations",
            "code": "REQUIRE_CALL(printer, print(\"A\"));\nREQUIRE_CALL(printer, print(\"B\"));\n\nprinter.print(\"A\");\nprinter.print(\"B\");",
            "explanation": "Verifies that multiple calls happen in the expected way."
          },
          {
            "title": "Controlling call counts",
            "code": "ALLOW_CALL(printer, print(trompeloeil::_)).TIMES(2);\n\nprinter.print(\"Hi\");\nprinter.print(\"Bye\");",
            "explanation": "Allows a method to be called exactly two times with any string."
          },
          {
            "title": "Returning values",
            "code": "struct Reader {\n    virtual int read() = 0;\n};\n\nstruct MockReader : Reader {\n    MAKE_MOCK0(read, int(), override);\n};\n\nMockReader reader;\nREQUIRE_CALL(reader, read()).RETURN(42);\nCHECK(reader.read() == 42);",
            "explanation": "Mocks a method that returns a value and specifies the return."
          },
          {
            "title": "Sequences of calls",
            "code": "trompeloeil::sequence seq;\nREQUIRE_CALL(printer, print(\"First\")) .IN_SEQUENCE(seq);\nREQUIRE_CALL(printer, print(\"Second\")) .IN_SEQUENCE(seq);\n\nprinter.print(\"First\");\nprinter.print(\"Second\");",
            "explanation": "Ensures methods are called in a specific order."
          }
        ],
        "best_practices": [
          "Use Trompeloeil with a test framework like Catch2 or Google Test for assertions.",
          "Keep mocks small and focused on the interaction under test.",
          "Use `ALLOW_CALL` for setup, and `REQUIRE_CALL` to enforce critical expectations.",
          "Leverage `.TIMES()`, `.RETURN()`, and `.IN_SEQUENCE()` to fine-tune behavior.",
          "Prefer mocking interfaces or abstract base classes rather than concrete implementations."
        ],
        "error_handling": [
          {
            "error": "Unexpected call",
            "solution": "Use `ALLOW_CALL` for calls that are optional, or add missing `REQUIRE_CALL` expectations."
          },
          {
            "error": "Call count mismatch",
            "solution": "Check `.TIMES()` or ensure test logic calls the mock the expected number of times."
          },
          {
            "error": "Segfaults on mock usage",
            "solution": "Ensure mocked objects outlive their expectations and are not destroyed prematurely."
          }
        ]
      },
      "references": {
        "official_docs": "https://github.com/rollbear/trompeloeil",
        "github": "https://github.com/rollbear/trompeloeil"
      }
    },
    {
      "id": "glog",
      "name": "glog (Google Logging Library)",
      "category": "Logging",
      "description": "glog is Google’s C++ logging library that provides application-level logging with different severity levels (INFO, WARNING, ERROR, FATAL). It is designed for robustness, simplicity, and performance, making it suitable for large-scale systems.",
      "story": "glog was developed at Google to provide developers with a powerful yet simple logging solution for C++ projects. Unlike syslog or printf-based approaches, glog adds structured logging with severity levels, stack traces on fatal errors, and flexible runtime configuration. It has since been open-sourced and is widely used across many C++ projects.",
      "installation": {
        "cmake": "find_package(glog CONFIG REQUIRED)",
        "vcpkg": "vcpkg install glog",
        "conan": "conan install glog",
        "manual": "git clone https://github.com/google/glog && cmake . && make && make install"
      },
      "usage": {
        "overview": "glog provides macros for logging at different severity levels. It also supports logging to files, conditional logging, and custom log sinks.",
        "basic_examples": [
          {
            "title": "Simple logging",
            "code": "#include <glog/logging.h>\n\nint main(int argc, char* argv[]) {\n    google::InitGoogleLogging(argv[0]);\n    LOG(INFO) << \"This is an info message.\";\n    LOG(WARNING) << \"This is a warning message.\";\n    LOG(ERROR) << \"This is an error message.\";\n    // LOG(FATAL) << \"This is fatal and will terminate.\";\n    return 0;\n}",
            "explanation": "Logs messages at different severity levels. `FATAL` logs terminate the program after printing a stack trace."
          }
        ],
        "advanced_examples": [
          {
            "title": "Conditional logging",
            "code": "int x = 5;\nLOG_IF(INFO, x > 0) << \"x is positive\";",
            "explanation": "Logs a message only if the condition is true."
          },
          {
            "title": "Verbose logging",
            "code": "FLAGS_v = 2;\nVLOG(1) << \"Verbose logging at level 1\";\nVLOG(2) << \"Verbose logging at level 2\";",
            "explanation": "Provides verbose logging with runtime-controlled levels."
          },
          {
            "title": "Check macros",
            "code": "int* ptr = nullptr;\nCHECK_NOTNULL(ptr);",
            "explanation": "`CHECK` macros validate conditions and abort with logs if they fail."
          },
          {
            "title": "Custom log sink",
            "code": "class MyLogSink : public google::LogSink {\n  void send(google::LogSeverity severity, const char* full_filename,\n            const char* base_filename, int line, const struct ::tm* tm_time,\n            const char* message, size_t message_len) override {\n      std::cout << \"Custom log: \" << message << std::endl;\n  }\n};\n\nMyLogSink sink;\ngoogle::AddLogSink(&sink);",
            "explanation": "Implements a custom sink to redirect logs to a different output."
          }
        ],
        "best_practices": [
          "Initialize glog early in the main function using `InitGoogleLogging`.",
          "Use severity levels consistently to separate normal logs from warnings and errors.",
          "Avoid `LOG(FATAL)` except for unrecoverable errors; it terminates the application.",
          "Use `CHECK` macros to enforce invariants in critical code paths.",
          "Combine glog with monitoring tools by redirecting log sinks if necessary."
        ],
        "error_handling": [
          {
            "error": "Logs not appearing",
            "solution": "Ensure `InitGoogleLogging` is called and check that log files are accessible."
          },
          {
            "error": "Fatal errors terminate unexpectedly",
            "solution": "Use `LOG(ERROR)` instead of `LOG(FATAL)` unless termination is required."
          },
          {
            "error": "Performance overhead in production",
            "solution": "Use lower verbosity levels and disable unnecessary logs with runtime flags."
          }
        ]
      },
      "references": {
        "official_docs": "https://github.com/google/glog",
        "github": "https://github.com/google/glog"
      }
    },
    {
      "id": "plog",
      "name": "plog",
      "category": "Logging",
      "description": "plog is a portable, simple, and extensible C++ logging library. It supports multiple logging destinations, severity levels, thread safety, and works across platforms with minimal dependencies.",
      "story": "plog was created to provide a lightweight and portable alternative to heavier C++ logging libraries like log4cxx and glog. It is header-only, easy to integrate, and flexible enough for both small applications and large systems. Its modular design allows developers to plug in custom appenders and formatters.",
      "installation": {
        "cmake": "add_subdirectory(plog)",
        "vcpkg": "vcpkg install plog",
        "conan": "conan install plog",
        "manual": "Download plog headers and include them in your project"
      },
      "usage": {
        "overview": "plog uses macros for logging at different severity levels and supports multiple appenders (console, file, etc.).",
        "basic_examples": [
          {
            "title": "Initialize and log",
            "code": "#include <plog/Log.h>\n#include <plog/Initializers/RollingFileInitializer.h>\n\nint main() {\n    plog::init(plog::debug, \"log.txt\");\n    PLOGD << \"This is a debug message\";\n    PLOGI << \"This is an info message\";\n    PLOGW << \"This is a warning\";\n    PLOGE << \"This is an error\";\n    PLOGF << \"This is fatal\";\n    return 0;\n}",
            "explanation": "Initializes plog with rolling file logs and writes messages at different severity levels."
          }
        ],
        "advanced_examples": [
          {
            "title": "Multiple appenders",
            "code": "plog::init(plog::debug, \"log.txt\").addAppender(new plog::ConsoleAppender<plog::TxtFormatter>());\nPLOGI << \"Log to both console and file\";",
            "explanation": "Logs messages to both file and console simultaneously."
          },
          {
            "title": "Custom formatter",
            "code": "struct MyFormatter {\n    static std::ostream& header(std::ostream& stream) { return stream; }\n    static std::ostream& format(std::ostream& stream, const plog::Record& record) {\n        return stream << record.getMessage() << \" (custom)\\n\";\n    }\n};\n\nplog::init(plog::debug, \"log.txt\", true, 1000, 3).addAppender(new plog::ConsoleAppender<MyFormatter>());\nPLOGI << \"Custom formatted log\";",
            "explanation": "Demonstrates creating a custom log formatter."
          },
          {
            "title": "Rolling file logging",
            "code": "plog::init(plog::debug, \"log.txt\", 1000, 5);\nPLOGI << \"Logs will roll over every 1000 lines, keeping 5 backups.\";",
            "explanation": "Configures rolling logs with file size and count limits."
          }
        ],
        "best_practices": [
          "Initialize logging early in the main function before other components run.",
          "Use different severity levels consistently to filter logs easily.",
          "Combine file and console appenders to keep persistent and real-time logs.",
          "Use rolling file logging to avoid uncontrolled log growth.",
          "Implement custom formatters if you need structured logs (e.g., JSON)."
        ],
        "error_handling": [
          {
            "error": "Logs not written to file",
            "solution": "Check file path permissions and ensure `plog::init` is called before logging."
          },
          {
            "error": "Too much log output",
            "solution": "Adjust the severity threshold passed to `plog::init` (e.g., `plog::info`)."
          },
          {
            "error": "Thread-safety issues",
            "solution": "plog is thread-safe, but custom appenders must ensure safe writes."
          }
        ]
      },
      "references": {
        "official_docs": "https://github.com/SergiusTheBest/plog",
        "github": "https://github.com/SergiusTheBest/plog"
      }
    }
  ]